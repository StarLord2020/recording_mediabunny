<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny + Screen Recording Demo</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <style>
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
  </style>
  <!--
    –ü–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏ (npm install && npm run build) –ø–æ–¥–∫–ª—é—á–∞–µ–º dist/mediabunny.umd.js.
    –ì–ª–æ–±–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ window.Mediabunny
  -->
  
</head>
<body>
  <h2>üé¨ –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞ –∏ —Å–±–æ—Ä–∫–∏ WebM —Å Mediabunny (UMD)</h2>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

  <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
  <video id="result" controls></video>

  <script>
    const preview = document.getElementById('preview');
    const result = document.getElementById('result');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');

    let recorder, chunks = [];

    async function startRecording() {
      // –ó–∞—Ö–≤–∞—Ç —Ç–æ–ª—å–∫–æ —ç–∫—Ä–∞–Ω–∞. –ü–æ—Å—Ç–∞–≤—å—Ç–µ audio: true, –µ—Å–ª–∏ –Ω—É–∂–µ–Ω —Å–∏—Å—Ç–µ–º–Ω—ã–π –∑–≤—É–∫ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –Ω–µ –≤–æ –≤—Å–µ—Ö –±—Ä–∞—É–∑–µ—Ä–∞—Ö)
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
      preview.srcObject = stream;

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      chunks = [];

      recorder.ondataavailable = e => {
        if (e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstop = async () => {
        console.log("‚è≥ –ü–µ—Ä–µ—Å–±–æ—Ä–∫–∞ WebM —á–µ—Ä–µ–∑ Mediabunny...");
        const fixedBlob = await rebuildWebM(chunks);
        const url = URL.createObjectURL(fixedBlob);
        result.src = url;

        // –ê–≤—Ç–æ—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `screen-recording-${ts}.webm`;
        document.body.appendChild(a);
        a.click();
        a.remove();

        console.log("‚úÖ –ì–æ—Ç–æ–≤–æ, —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω –∏ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞");
      };

      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç —à–∞—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ UI –±—Ä–∞—É–∑–µ—Ä–∞, –∑–∞–≤–µ—Ä—à–∏–º –∑–∞–ø–∏—Å—å
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };

      recorder.start(1000); // –ø–∏—Å–∞—Ç—å —á–∞–Ω–∫–∞–º–∏ –ø–æ 1—Å
      startBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stopRecording() {
      recorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      preview.srcObject.getTracks().forEach(t => t.stop());
    }

    async function rebuildWebM(chunks) {
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;

      const fullBlob = new Blob(chunks, { type: 'video/webm' });
      const input = new Input({ source: new BlobSource(fullBlob), formats: [WEBM] });

      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });

      const conversion = await Conversion.init({ input, output });
      await conversion.execute();

      const buffer = target.buffer;
      return new Blob([buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;
  </script>
</body>
</html>
