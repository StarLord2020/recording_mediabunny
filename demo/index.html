<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny + Screen Recording Demo</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <script src="./idb-recorder.js"></script>
  <style>
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress {
      position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.15);
    }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#4caf50,#2e7d32); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
  <!--
    –ü–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏ (npm install && npm run build) –ø–æ–¥–∫–ª—é—á–∞–µ–º dist/mediabunny.umd.js.
    –ì–ª–æ–±–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ window.Mediabunny
  -->
  
</head>
<body>
  <h2>üé¨ –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞ –∏ —Å–±–æ—Ä–∫–∏ WebM —Å Mediabunny (UMD)</h2>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
  <label style="margin-left:10px; font: 13px system-ui, sans-serif; display:none;">
    <input type="checkbox" id="saveToFile"> –°–æ—Ö—Ä–∞–Ω—è—Ç—å –Ω–∞–ø—Ä—è–º—É—é –≤ —Ñ–∞–π–ª (Chrome/Edge)
  </label>

  <div id="recInfo" style="display:none; margin: 0 10px; font: 13px system-ui, sans-serif; color:#b71c1c;">
    <span style="display:inline-block; width:10px; height:10px; background:#e53935; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>

  <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–º –ø–ª–µ–µ—Ä–µ, —ç–∫–æ–Ω–æ–º–∏–º –ø–∞–º—è—Ç—å -->

  <script>
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');

    let recorder;
    let recTimerId = null;
    let recStartMs = 0;
    let worker = null;
    let fsWritable = null; // FileSystemWritableFileStream
    let idbWriter = null;  // IndexedDB writer

    async function startRecording() {
      // –ó–∞—Ö–≤–∞—Ç —ç–∫—Ä–∞–Ω–∞ + —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –∑–≤—É–∫–∞ (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º)
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MediaRecorder
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IndexedDB-—Å–µ—Å—Å–∏–∏ (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º UI)
      try {
        idbWriter = new IDBWriter();
        idbRequestPersistence?.();
        currentSessionId = await idbWriter.start({ filenameBase: 'screen-recording', mimeType: 'video/webm', roomId: undefined });
      } catch (e) {
        console.warn('IDB session init failed:', e);
        idbWriter = null;
        currentSessionId = null;
      }

      recorder.ondataavailable = e => {
        // –ü–∏—à–µ–º —á–∞–Ω–∫ —Å—Ä–∞–∑—É –≤ IndexedDB, –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º
        if (e.data && e.data.size > 0) {
          try { idbWriter?.enqueue(e.data); } catch (_) {}
        }
      };

      recorder.onstop = async () => {
        console.log("‚è≥ –ü–µ—Ä–µ—Å–±–æ—Ä–∫–∞ WebM (remux) –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ...");
        progressEl.style.display = '';
        progressTextEl.style.display = '';
        updateProgress(0);

        const t0 = performance.now();

        // –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞ –∑–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª ‚Äî –¥–µ–ª–∞–µ–º —Ä–µ–º–∞–∫—Å –∏–∑ IndexedDB –ø—Ä—è–º–æ –≤ —Ñ–∞–π–ª (–Ω–∞–¥—ë–∂–Ω–µ–µ)
        if (fsWritable && currentSessionId) {
          try {
            await remuxToFileFromIDB(currentSessionId, 'video/webm', t0, fsWritable);
          } catch (e) {
            console.warn('Stream-to-file (main thread) failed:', e);
            try { await fsWritable.close(); } catch (_) {}
            fsWritable = null;
            // –§–æ–ª–±—ç–∫: —Å–æ–±–∏—Ä–∞–µ–º Blob –∏–∑ IndexedDB –∏ —Ä–µ–º–∞–∫—Å–∏–º –≤ –ø–∞–º—è—Ç–∏
            const fullBlob = await buildBlobFromIDB(currentSessionId);
            const fixedBlob = await rebuildBlobWebM(fullBlob);
            handleReadyBlob(fixedBlob, performance.now() - t0);
          } finally {
            fsWritable = null;
          }
        } else {
          // –ù–µ—Ç –ø–æ—Ç–æ–∫–∞ –≤ —Ñ–∞–π–ª: —Å–æ–±–∏—Ä–∞–µ–º Blob –∏–∑ IndexedDB –∏ —Ä–µ–º–∞–∫—Å–∏–º –≤ –ø–∞–º—è—Ç–∏
          const fullBlob = await buildBlobFromIDB(currentSessionId);
          const fixedBlob = await rebuildBlobWebM(fullBlob);
          handleReadyBlob(fixedBlob, performance.now() - t0);
        }
      };

      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç —à–∞—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ UI –±—Ä–∞—É–∑–µ—Ä–∞, –∑–∞–≤–µ—Ä—à–∏–º –∑–∞–ø–∏—Å—å
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };

      recorder.start(1000); // –ø–∏—Å–∞—Ç—å —á–∞–Ω–∫–∞–º–∏ –ø–æ 1—Å
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∏ –∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ç–∞–π–º–µ—Ä
      recStartMs = performance.now();
      document.getElementById('recInfo').style.display = '';
      updateRecTime(0);
      recTimerId = setInterval(() => {
        const ms = performance.now() - recStartMs;
        updateRecTime(ms);
      }, 250);
    }

    async function stopRecording() {
      // –í—Å–µ–≥–¥–∞ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –ø–æ—Ç–æ–∫–æ–≤—É—é –∑–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω FS API
      const wantStream = !!window.showSaveFilePicker;
      if (wantStream && window.showSaveFilePicker && !fsWritable) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm`,
            types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }]
          });
          fsWritable = await handle.createWritable();
          try { await fsWritable.truncate(0); } catch (_) {}
        } catch (e) {
          console.warn('–í—ã–±–æ—Ä —Ñ–∞–π–ª–∞ –æ—Ç–º–µ–Ω—ë–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ FS API:', e);
        }
      }
      recorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (preview.srcObject) {
        preview.srcObject.getTracks().forEach(t => t.stop());
        preview.srcObject = null;
      }

      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';

      // –ó–∞–≤–µ—Ä—à–∞–µ–º IDB-—Å–µ—Å—Å–∏—é (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ø—É—Ç—å)
      try { await idbWriter?.stop(); } catch (e) { console.warn('IDB stop failed:', e); }
      idbWriter = null;
    }

    async function rebuildWebM(chunks) {
      console.log
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;

      const fullBlob = new Blob(chunks, { type: 'video/webm' });
      const input = new Input({ source: new BlobSource(fullBlob), formats: [WEBM] });

      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });

      const conversion = await Conversion.init({ input, output, audio: { forceTranscode: true } });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
        console.log(`üìà Mediabunny progress: ${(percent * 100).toFixed(1)}%`);
      };
      await conversion.execute();

      const buffer = target.buffer;
      console.log(target, 'target target target');
      return new Blob([buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }

    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    async function remuxInWorker() {
      try {
        // worker path is disabled when using IDB-only flow
        console.warn('Worker remux path disabled in IDB-only mode');
      } catch (err) {
        console.warn('Worker remux error:', err);
        // fallback handled in onstop branch via IDB blob path
      } finally {
        if (worker) { worker.terminate(); worker = null; }
      }
    }

    async function remuxToFileFromIDB(sessionId, mimeType, t0, writable) {
      const { Input, Output, WebMOutputFormat, StreamTarget, ReadableStreamSource, WEBM, Conversion } = window.Mediabunny;
      try { await writable.truncate?.(0); } catch (_) {}

      // –†–µ–∞–ª–∏–∑—É–µ–º –ø–æ—Ç–æ–∫ –∏–∑ IDB —á–µ—Ä–µ–∑ –∫—É—Ä—Å–æ—Ä –∏ backpressure: –æ—Ç–¥–∞—ë–º —Å–ª–µ–¥—É—é—â–∏–π —á–∞–Ω–∫ —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å –∑–∞–ø—Ä–æ—Å–∏—Ç
      const db = await idbOpenDB();
      // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏, –≤–∫–ª—é—á–∞—è –æ–∂–∏–¥–∞–µ–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞–Ω–∫–æ–≤
      const sess = await new Promise((res, rej) => {
        const tx = db.transaction('sessions','readonly');
        const r = tx.objectStore('sessions').get(sessionId);
        r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
      });
      if (!sess) throw new Error('Session not found');
      const expectedCount = typeof sess.chunkCount === 'number' ? sess.chunkCount : null;

      // –ë—É–¥–µ–º —á–∏—Ç–∞—Ç—å –ø–æ –æ–¥–Ω–æ–º—É —á–∞–Ω–∫—É –∑–∞ pull, —Å–æ–∑–¥–∞–≤–∞—è –∫–æ—Ä–æ—Ç–∫–æ–∂–∏–≤—É—â—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∫–∞–∂–¥—ã–π —Ä–∞–∑
      let nextSeq = 0;
      let reachedEnd = false;
      const stream = new ReadableStream({
        async pull(controller) {
          if (reachedEnd) {
            controller.close();
            return;
          }
          try {
            // –ï—Å–ª–∏ –∑–Ω–∞–µ–º –æ–∂–∏–¥–∞–µ–º–æ–µ —á–∏—Å–ª–æ —á–∞–Ω–∫–æ–≤ –∏ –≤—Å—ë —É–∂–µ –ø—Ä–æ—á–∏—Ç–∞–Ω–æ ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º—Å—è
            if (expectedCount !== null && nextSeq >= expectedCount) {
              reachedEnd = true;
              controller.close();
              return;
            }
            // –ë—ã—Å—Ç—Ä—ã–π –ø—É—Ç—å: —Ç–æ—á–µ—á–Ω—ã–π get –ø–æ —Å–æ—Å—Ç–∞–≤–Ω–æ–º—É –∫–ª—é—á—É
            const tx1 = db.transaction('chunks', 'readonly');
            const store1 = tx1.objectStore('chunks');
            const row = await new Promise((res, rej) => {
              const g = store1.get([sessionId, nextSeq]);
              g.onsuccess = () => res(g.result);
              g.onerror = () => rej(g.error);
            });
            if (row) {
              const blob = row.blob || new Blob([row.ab], { type: mimeType });
              const ab = await blob.arrayBuffer();
              controller.enqueue(new Uint8Array(ab));
              nextSeq = (row.seq || nextSeq) + 1;
              return;
            }
            // –ó–∞–ø–∞—Å–Ω–æ–π –ø—É—Ç—å: –∫—É—Ä—Å–æ—Ä –≤ —Ä–∞–º–∫–∞—Ö —Ç–µ–∫—É—â–µ–π —Å–µ—Å—Å–∏–∏, –Ω–∞—á–∏–Ω–∞—è —Å nextSeq
            const tx2 = db.transaction('chunks', 'readonly');
            const store2 = tx2.objectStore('chunks');
            const range = IDBKeyRange.bound([sessionId, nextSeq], [sessionId, Number.MAX_SAFE_INTEGER]);
            const req = store2.openCursor(range);
            const cursor = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error); });
            if (!cursor) {
              reachedEnd = true;
              controller.close();
              return;
            }
            const row2 = cursor.value;
            const blob2 = row2.blob || new Blob([row2.ab], { type: mimeType });
            const ab2 = await blob2.arrayBuffer();
            controller.enqueue(new Uint8Array(ab2));
            nextSeq = (row2.seq || nextSeq) + 1;
          } catch (e) {
            controller.error(e);
          }
        },
      });

      // –í–∞–∂–Ω–æ–µ: —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–µ—à –∏—Å—Ç–æ—á–Ω–∏–∫–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è ¬´–¥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ–≥–∏–æ–Ω–∞¬ª
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: 64 * 1024 * 1024 }), formats: [WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output, audio: { forceTranscode: true } });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
        console.log(`üìà Mediabunny progress (file from IDB): ${(percent * 100).toFixed(1)}%`);
      };
      await conversion.execute();
      try { await writable.close(); } catch (_) {}
      const elapsed = performance.now() - t0;
      console.log(`‚è±Ô∏è rebuildWebM (file from IDB) –∑–∞–Ω—è–ª–æ ${elapsed.toFixed(1)} –º—Å`);
      updateProgress(1);
      setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }

    async function buildBlobFromIDB(sessionId) {
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => {
        const tx = db.transaction('sessions','readonly');
        const r = tx.objectStore('sessions').get(sessionId);
        r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
      });
      if (!sess) throw new Error('Session not found');
      const rows = await new Promise((res, rej) => {
        const tx = db.transaction('chunks','readonly');
        const idx = tx.objectStore('chunks').index('bySession');
        const req = idx.getAll(IDBKeyRange.only(sessionId));
        req.onsuccess = () => res(req.result.sort((a,b)=>a.seq-b.seq));
        req.onerror = () => rej(req.error);
      });
      const parts = rows.map((r) => r.blob || new Blob([r.ab], { type: 'video/webm' }));
      return new Blob(parts, { type: 'video/webm' });
    }

    function handleReadyBlob(fixedBlob, elapsedMs) {
      const url = URL.createObjectURL(fixedBlob);

      // –ê–≤—Ç–æ—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–±–µ–∑ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø–ª–µ–µ—Ä–µ)
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `screen-recording-${ts}.webm`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);

      console.log(`‚è±Ô∏è rebuildWebM –∑–∞–Ω—è–ª–æ ${elapsedMs.toFixed(1)} –º—Å`);
      console.log('‚úÖ –ì–æ—Ç–æ–≤–æ, —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω –∏ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞');
      // –°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
      updateProgress(1);
      setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }

    // –•–µ–ª–ø–µ—Ä –¥–ª—è —Ñ–æ–ª–±—ç–∫–∞: —Ä–µ–º–∞–∫—Å –∏–∑ –æ–¥–Ω–æ–≥–æ Blob (–±–µ–∑ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞)
    async function rebuildBlobWebM(blob) {
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;
      const input = new Input({ source: new BlobSource(blob), formats: [WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output, audio: { forceTranscode: true } });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
      };
      await conversion.execute();
      return new Blob([target.buffer], { type: 'video/webm' });
    }
  </script>
</body>
</html>
