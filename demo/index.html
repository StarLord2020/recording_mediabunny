<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny + Screen Recording Demo</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <script src="./idb-recorder.js"></script>
  <style>
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress {
      position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.15);
    }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#4caf50,#2e7d32); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
  <!--
    –ü–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏ (npm install && npm run build) –ø–æ–¥–∫–ª—é—á–∞–µ–º dist/mediabunny.umd.js.
    –ì–ª–æ–±–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ window.Mediabunny
  -->
  
</head>
<body>
  <h2>üé¨ –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞ –∏ —Å–±–æ—Ä–∫–∏ WebM —Å Mediabunny (UMD)</h2>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
  <label style="margin-left:10px; font: 13px system-ui, sans-serif;">
    –ö–æ–¥–µ–∫:
    <select id="codecSelect">
      <option value="auto" selected>–ê–≤—Ç–æ (–ª—É—á—à–∏–π –¥–æ—Å—Ç—É–ø–Ω—ã–π)</option>
      <option value="video/webm; codecs=vp9,opus">WebM: VP9 + Opus</option>
      <option value="video/webm; codecs=vp8,opus">WebM: VP8 + Opus</option>
      <option value="video/webm">WebM (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)</option>
      <option value="video/mp4">MP4 (H.264/AAC)</option>
    </select>
  </label>
  <label style="margin-left:10px; font: 13px system-ui, sans-serif; display:none;">
    <input type="checkbox" id="saveToFile"> –°–æ—Ö—Ä–∞–Ω—è—Ç—å –Ω–∞–ø—Ä—è–º—É—é –≤ —Ñ–∞–π–ª (Chrome/Edge)
  </label>

  <div id="recInfo" style="display:none; margin: 0 10px; font: 13px system-ui, sans-serif; color:#b71c1c;">
    <span style="display:inline-block; width:10px; height:10px; background:#e53935; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>
  <div class="progress" id="progressIndex" style="display:none">
    <div class="progress__bar" id="progressIndexBar"></div>
  </div>
  <div class="progress__text" id="progressIndexText" style="display:none">–ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è 0%</div>

  <div style="margin:12px 10px; font: 13px system-ui, sans-serif;">
    <strong>–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å–µ—Å—Å–∏–∏</strong>
    <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
      <select id="sessionSelect" style="min-width:320px;"></select>
      <button id="refreshSessionsBtn">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
      <button id="processSelectedBtn">üíæ –°–æ–±—Ä–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é –≤ —Ñ–∞–π–ª</button>
    </div>
  </div>

  <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–º –ø–ª–µ–µ—Ä–µ, —ç–∫–æ–Ω–æ–º–∏–º –ø–∞–º—è—Ç—å -->

  <script>
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');
    const progressIndexEl = document.getElementById('progressIndex');
    const progressIndexBarEl = document.getElementById('progressIndexBar');
    const progressIndexTextEl = document.getElementById('progressIndexText');
    const sessionSelectEl = document.getElementById('sessionSelect');
    const refreshSessionsBtn = document.getElementById('refreshSessionsBtn');
    const processSelectedBtn = document.getElementById('processSelectedBtn');
    const codecSelect = document.getElementById('codecSelect');

    let recorder;
    let recTimerId = null;
    let recStartMs = 0;
    let worker = null;
    let fsWritable = null; // FileSystemWritableFileStream
    let idbWriter = null;  // IndexedDB writer

    function updateCodecOptionsSupport() {
      if (!window.MediaRecorder) return;
      const opts = Array.from(codecSelect.options).filter(o => o.value !== 'auto');
      for (const o of opts) {
        try {
          const sup = MediaRecorder.isTypeSupported(o.value);
          o.disabled = !sup;
          o.textContent = o.textContent.replace(/ \(–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è\)$/,'') + (sup ? '' : ' (–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)');
        } catch (_) {
          o.disabled = true;
          o.textContent = o.textContent.replace(/ \(–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è\)$/,'') + ' (–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)';
        }
      }
    }

    function resolveMimeSelection() {
      const selected = codecSelect.value;
      const candidates = [
        'video/webm; codecs=vp9,opus',
        'video/webm; codecs=vp8,opus',
        'video/webm',
        'video/mp4'
      ];
      const tryList = selected === 'auto' ? candidates : [selected, ...candidates.filter(x => x !== selected)];
      for (const mt of tryList) { if (MediaRecorder.isTypeSupported(mt)) return mt; }
      // Fallback to browser default
      return '';
    }

    async function startRecording() {
      // –ó–∞—Ö–≤–∞—Ç —ç–∫—Ä–∞–Ω–∞ + —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –∑–≤—É–∫–∞ (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º)
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MediaRecorder
      updateCodecOptionsSupport();
      const chosenMime = resolveMimeSelection();
      recorder = chosenMime ? new MediaRecorder(stream, { mimeType: chosenMime }) : new MediaRecorder(stream);
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IndexedDB-—Å–µ—Å—Å–∏–∏ (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º UI)
      try {
        idbWriter = new IDBWriter();
        idbRequestPersistence?.();
        const sessMime = recorder.mimeType || chosenMime || 'video/webm';
        currentSessionId = await idbWriter.start({ filenameBase: 'screen-recording', mimeType: sessMime, roomId: undefined });
      } catch (e) {
        console.warn('IDB session init failed:', e);
        idbWriter = null;
        currentSessionId = null;
      }

      recorder.ondataavailable = e => {
        // –ü–∏—à–µ–º —á–∞–Ω–∫ —Å—Ä–∞–∑—É –≤ IndexedDB, –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º
        if (e.data && e.data.size > 0) {
          try { idbWriter?.enqueue(e.data); } catch (_) {}
        }
      };

      recorder.onstop = async () => {
        console.log("‚è≥ –ü–µ—Ä–µ—Å–±–æ—Ä–∫–∞ WebM (remux) –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ...");
        progressEl.style.display = '';
        progressTextEl.style.display = '';
        updateProgress(0);

        const t0 = performance.now();

        // –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞ –∑–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª ‚Äî –¥–µ–ª–∞–µ–º —Ä–µ–º–∞–∫—Å –∏–∑ IndexedDB –ø—Ä—è–º–æ –≤ —Ñ–∞–π–ª (–Ω–∞–¥—ë–∂–Ω–µ–µ)
        if (fsWritable && currentSessionId) {
          try {
            await remuxToFileFromIDB(currentSessionId, recorder?.mimeType || 'video/webm', t0, fsWritable);
          } catch (e) {
            console.warn('Stream-to-file (main thread) failed:', e);
            try { await fsWritable.close(); } catch (_) {}
            fsWritable = null;
            // –§–æ–ª–±—ç–∫: —Å–æ–±–∏—Ä–∞–µ–º Blob –∏–∑ IndexedDB –∏ —Ä–µ–º–∞–∫—Å–∏–º –≤ –ø–∞–º—è—Ç–∏
            const fullBlob = await buildBlobFromIDB(currentSessionId, recorder?.mimeType || 'video/webm');
            const fixedBlob = await rebuildBlobWebM(fullBlob);
            handleReadyBlob(fixedBlob, performance.now() - t0);
          } finally {
            fsWritable = null;
          }
        } else {
          // –ù–µ—Ç –ø–æ—Ç–æ–∫–∞ –≤ —Ñ–∞–π–ª: —Å–æ–±–∏—Ä–∞–µ–º Blob –∏–∑ IndexedDB –∏ —Ä–µ–º–∞–∫—Å–∏–º –≤ –ø–∞–º—è—Ç–∏
          const fullBlob = await buildBlobFromIDB(currentSessionId, recorder?.mimeType || 'video/webm');
          const fixedBlob = await rebuildBlobWebM(fullBlob);
          handleReadyBlob(fixedBlob, performance.now() - t0);
        }
      };

      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç —à–∞—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ UI –±—Ä–∞—É–∑–µ—Ä–∞, –∑–∞–≤–µ—Ä—à–∏–º –∑–∞–ø–∏—Å—å
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };

      recorder.start(1000); // –ø–∏—Å–∞—Ç—å —á–∞–Ω–∫–∞–º–∏ –ø–æ 1—Å
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∏ –∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ç–∞–π–º–µ—Ä
      recStartMs = performance.now();
      document.getElementById('recInfo').style.display = '';
      updateRecTime(0);
      recTimerId = setInterval(() => {
        const ms = performance.now() - recStartMs;
        updateRecTime(ms);
      }, 250);
    }

    async function stopRecording() {
      // –í—Å–µ–≥–¥–∞ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –ø–æ—Ç–æ–∫–æ–≤—É—é –∑–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω FS API
      const wantStream = !!window.showSaveFilePicker;
      if (wantStream && window.showSaveFilePicker && !fsWritable) {
        try {
          const mime = recorder?.mimeType || 'video/webm';
          const isMp4 = /^video\/mp4/.test(mime);
          const handle = await window.showSaveFilePicker({
            suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4 ? 'mp4' : 'webm'}`,
            types: [ isMp4 ? { description: 'MP4 Video', accept: { 'video/mp4': ['.mp4'] } } : { description: 'WebM Video', accept: { 'video/webm': ['.webm'] } } ]
          });
          fsWritable = await handle.createWritable();
          try { await fsWritable.truncate(0); } catch (_) {}
        } catch (e) {
          console.warn('–í—ã–±–æ—Ä —Ñ–∞–π–ª–∞ –æ—Ç–º–µ–Ω—ë–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ FS API:', e);
        }
      }
      recorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (preview.srcObject) {
        preview.srcObject.getTracks().forEach(t => t.stop());
        preview.srcObject = null;
      }

      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';

      // –ó–∞–≤–µ—Ä—à–∞–µ–º IDB-—Å–µ—Å—Å–∏—é (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ø—É—Ç—å)
      try { await idbWriter?.stop(); } catch (e) { console.warn('IDB stop failed:', e); }
      idbWriter = null;
    }

    async function rebuildWebM(chunks) {
      console.log
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;

      const fullBlob = new Blob(chunks, { type: 'video/webm' });
      const input = new Input({ source: new BlobSource(fullBlob), formats: [WEBM] });

      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });

      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
        console.log(`üìà Mediabunny progress: ${(percent * 100).toFixed(1)}%`);
      };
      await conversion.execute();

      const buffer = target.buffer;
      console.log(target, 'target target target');
      return new Blob([buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;
    refreshSessionsBtn.onclick = loadSessionsIntoSelect;
    processSelectedBtn.onclick = processSelectedSession;

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }
    function updateIndexProgress(p) {
      const clamped = Math.max(0, Math.min(1, p));
      progressIndexBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressIndexTextEl.textContent = `–ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è ${(clamped*100).toFixed(1)}%`;
    }

    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    async function loadSessionsIntoSelect() {
      try {
        sessionSelectEl.innerHTML = '';
        const sessions = await idbListSessions();
        sessions.sort((a,b)=> (b.startedAt||0) - (a.startedAt||0));
        for (const s of sessions) {
          const started = s.startedAt ? new Date(s.startedAt).toLocaleString() : '–±–µ–∑ –¥–∞—Ç—ã';
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = `${started} ‚Äî ${s.chunkCount||0} —á–∞–Ω–∫–æ–≤`;
          opt.dataset.mime = s.mimeType || 'video/webm';
          sessionSelectEl.appendChild(opt);
        }
      } catch (e) {
        console.warn('loadSessionsIntoSelect failed:', e);
      }
    }

    async function processSelectedSession() {
      try {
        const sessId = sessionSelectEl.value;
        if (!sessId) { alert('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Å—Å–∏—é'); return; }
        if (!window.showSaveFilePicker) { alert('–ù—É–∂–µ–Ω File System Access API (Chrome/Edge)'); return; }
        const mime = sessionSelectEl.options[sessionSelectEl.selectedIndex]?.dataset?.mime || 'video/webm';
        const isMp4 = /^video\/mp4/.test(mime);
        const handle = await window.showSaveFilePicker({
          suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4 ? 'mp4' : 'webm'}`,
          types: [ isMp4 ? { description: 'MP4 Video', accept: { 'video/mp4': ['.mp4'] } } : { description: 'WebM Video', accept: { 'video/webm': ['.webm'] } } ]
        });
        const writable = await handle.createWritable({ keepExistingData: false });
        try { await writable.truncate(0); } catch(_) {}
        progressEl.style.display = '';
        progressTextEl.style.display = '';
        updateProgress(0);
        const t0 = performance.now();
        await remuxToFileFromIDB(sessId, mime, t0, writable);
      } catch (e) {
        console.warn('Process selected session failed:', e);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é —Å–µ—Å—Å–∏—é');
      }
    }

    // –ü–æ–¥–≥—Ä—É–∑–∏–º —Å–ø–∏—Å–æ–∫ —Å–µ—Å—Å–∏–π –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    loadSessionsIntoSelect();

    async function remuxInWorker() {
      try {
        // worker path is disabled when using IDB-only flow
        console.warn('Worker remux path disabled in IDB-only mode');
      } catch (err) {
        console.warn('Worker remux error:', err);
        // fallback handled in onstop branch via IDB blob path
      } finally {
        if (worker) { worker.terminate(); worker = null; }
      }
    }

    async function remuxToFileFromIDB(sessionId, mimeType, t0, writable) {
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, StreamTarget, StreamSource, WEBM, MP4, Conversion } = window.Mediabunny;
      try { await writable.truncate?.(0); } catch (_) {}

      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => {
        const tx = db.transaction('sessions','readonly');
        const r = tx.objectStore('sessions').get(sessionId);
        r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
      });
      if (!sess) throw new Error('Session not found');
      const count = Number.isInteger(sess.chunkCount) ? sess.chunkCount : 0;
      if (count <= 0) throw new Error('No chunks recorded');

      // –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –∏–Ω–¥–µ–∫—Å—ã —Ä–∞–∑–º–µ—Ä–æ–≤ –¥–ª—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
      const sizes = new Array(count);
      let total = 0;
      // –ø–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏
      progressIndexEl.style.display = '';
      progressIndexTextEl.style.display = '';
      updateIndexProgress(0);
      for (let i = 0; i < count; i++) {
        const tx = db.transaction('chunks','readonly');
        const store = tx.objectStore('chunks');
        // eslint-disable-next-line no-await-in-loop
        const row = await new Promise((res, rej) => { const g = store.get([sessionId, i]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
        const sz = row?.blob ? row.blob.size : (row?.ab ? row.ab.byteLength : 0);
        sizes[i] = sz; total += sz;
        if ((i & 0xFF) === 0 || i === count-1) { updateIndexProgress((i+1)/count); await Promise.resolve(); }
      }
      const prefix = new Array(count); let acc = 0; for (let i = 0; i < count; i++) { prefix[i] = acc; acc += sizes[i]; }
      updateIndexProgress(1);
      setTimeout(()=>{ progressIndexEl.style.display='none'; progressIndexTextEl.style.display='none'; }, 400);
      const locateByOffset = (offset) => {
        let lo = 0, hi = count - 1, ans = 0;
        while (lo <= hi) { const mid = (lo + hi) >> 1; if (prefix[mid] <= offset) { ans = mid; lo = mid + 1; } else { hi = mid - 1; } }
        const seq = ans; const chunkOffset = offset - prefix[seq]; return { seq, chunkOffset };
      };

      let servedBytes = 0;
      const source = new StreamSource({
        getSize: () => total,
        read: async (start, end) => {
          const len = end - start; const out = new Uint8Array(len);
          let written = 0; let pos = start;
          while (written < len) {
            const { seq, chunkOffset } = locateByOffset(pos);
            const tx = db.transaction('chunks','readonly');
            const store = tx.objectStore('chunks');
            // eslint-disable-next-line no-await-in-loop
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk during read');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const take = Math.min(blob.size - chunkOffset, len - written);
            // eslint-disable-next-line no-await-in-loop
            const ab = await blob.slice(chunkOffset, chunkOffset + take).arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength; pos += ab.byteLength;
          }
          servedBytes += len;
          updateProgress(Math.max(0, Math.min(1, servedBytes / total)));
          return out;
        },
        maxCacheSize: 128 * 1024 * 1024,
        prefetchProfile: 'fileSystem'
      });
      const isMp4 = /^video\/mp4/.test(mimeType);
      const input = new Input({ source, formats: [isMp4 ? MP4 : WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      await conversion.execute();
      try { await writable.close(); } catch (_) {}
      const elapsed = performance.now() - t0;
      console.log(`‚è±Ô∏è rebuildWebM (file from IDB) –∑–∞–Ω—è–ª–æ ${elapsed.toFixed(1)} –º—Å`);
      updateProgress(1);
      setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }

    async function buildBlobFromIDB(sessionId, mimeType) {
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => {
        const tx = db.transaction('sessions','readonly');
        const r = tx.objectStore('sessions').get(sessionId);
        r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
      });
      if (!sess) throw new Error('Session not found');
      const rows = await new Promise((res, rej) => {
        const tx = db.transaction('chunks','readonly');
        const idx = tx.objectStore('chunks').index('bySession');
        const req = idx.getAll(IDBKeyRange.only(sessionId));
        req.onsuccess = () => res(req.result.sort((a,b)=>a.seq-b.seq));
        req.onerror = () => rej(req.error);
      });
      const mt = mimeType || sess.mimeType || 'video/webm';
      const parts = rows.map((r) => r.blob || new Blob([r.ab], { type: mt }));
      return new Blob(parts, { type: mt });
    }

    function handleReadyBlob(fixedBlob, elapsedMs) {
      const url = URL.createObjectURL(fixedBlob);

      // –ê–≤—Ç–æ—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–±–µ–∑ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø–ª–µ–µ—Ä–µ)
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      const isMp4 = /^video\/mp4/.test(fixedBlob.type);
      a.download = `screen-recording-${ts}.${isMp4 ? 'mp4' : 'webm'}`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);

      console.log(`‚è±Ô∏è rebuildWebM –∑–∞–Ω—è–ª–æ ${elapsedMs.toFixed(1)} –º—Å`);
      console.log('‚úÖ –ì–æ—Ç–æ–≤–æ, —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω –∏ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞');
      // –°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
      updateProgress(1);
      setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }

    // –•–µ–ª–ø–µ—Ä –¥–ª—è —Ñ–æ–ª–±—ç–∫–∞: —Ä–µ–º–∞–∫—Å –∏–∑ –æ–¥–Ω–æ–≥–æ Blob (–±–µ–∑ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞)
    async function rebuildBlobWebM(blob) {
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, BufferTarget, BlobSource, WEBM, MP4, Conversion } = window.Mediabunny;
      const isMp4 = /^video\/mp4/.test(blob.type);
      const input = new Input({ source: new BlobSource(blob), formats: [isMp4 ? MP4 : WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
      };
      await conversion.execute();
      return new Blob([target.buffer], { type: isMp4 ? 'video/mp4' : 'video/webm' });
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É –∫–æ–¥–µ–∫–æ–≤ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    updateCodecOptionsSupport();
  </script>
</body>
</html>
