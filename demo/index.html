<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny + Screen Recording Demo</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <style>
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress {
      position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.15);
    }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#4caf50,#2e7d32); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
  <!--
    –ü–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏ (npm install && npm run build) –ø–æ–¥–∫–ª—é—á–∞–µ–º dist/mediabunny.umd.js.
    –ì–ª–æ–±–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ window.Mediabunny
  -->
  
</head>
<body>
  <h2>üé¨ –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞ –∏ —Å–±–æ—Ä–∫–∏ WebM —Å Mediabunny (UMD)</h2>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

  <div id="recInfo" style="display:none; margin: 0 10px; font: 13px system-ui, sans-serif; color:#b71c1c;">
    <span style="display:inline-block; width:10px; height:10px; background:#e53935; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>

  <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
  <video id="result" controls></video>

  <script>
    const preview = document.getElementById('preview');
    const result = document.getElementById('result');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');

    let recorder, chunks = [];
    let recTimerId = null;
    let recStartMs = 0;
    let worker = null;

    async function startRecording() {
      // –ó–∞—Ö–≤–∞—Ç —ç–∫—Ä–∞–Ω–∞ + —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –∑–≤—É–∫–∞ (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º)
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      chunks = [];

      recorder.ondataavailable = e => {
        if (e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstop = async () => {
        console.log("‚è≥ –ü–µ—Ä–µ—Å–±–æ—Ä–∫–∞ WebM (remux) –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ...");
        progressEl.style.display = '';
        progressTextEl.style.display = '';
        updateProgress(0);

        const t0 = performance.now();

        // –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º Web Worker, —Ñ–æ–ª–±—ç–∫ ‚Äî inline
        if (window.Worker) {
          await remuxInWorker(chunks, 'video/webm', t0);
        } else {
          const fixedBlob = await rebuildWebM(chunks);
          handleReadyBlob(fixedBlob, performance.now() - t0);
        }
      };

      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç —à–∞—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ UI –±—Ä–∞—É–∑–µ—Ä–∞, –∑–∞–≤–µ—Ä—à–∏–º –∑–∞–ø–∏—Å—å
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };

      recorder.start(1000); // –ø–∏—Å–∞—Ç—å —á–∞–Ω–∫–∞–º–∏ –ø–æ 1—Å
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∏ –∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ç–∞–π–º–µ—Ä
      recStartMs = performance.now();
      document.getElementById('recInfo').style.display = '';
      updateRecTime(0);
      recTimerId = setInterval(() => {
        const ms = performance.now() - recStartMs;
        updateRecTime(ms);
      }, 250);
    }

    function stopRecording() {
      recorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      preview.srcObject.getTracks().forEach(t => t.stop());

      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';
    }

    async function rebuildWebM(chunks) {
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;

      const fullBlob = new Blob(chunks, { type: 'video/webm' });
      const input = new Input({ source: new BlobSource(fullBlob), formats: [WEBM] });

      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });

      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
        console.log(`üìà Mediabunny progress: ${(percent * 100).toFixed(1)}%`);
      };
      await conversion.execute();

      const buffer = target.buffer;
      return new Blob([buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }

    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    async function remuxInWorker(chunks, mimeType, t0) {
      try {
        if (worker) { worker.terminate(); worker = null; }
        worker = new Worker('remux.worker.js');
        await new Promise((resolve, reject) => {
          worker.onmessage = (ev) => {
            const { type } = ev.data || {};
            if (type === 'progress') {
              const p = Math.max(0, Math.min(1, ev.data.progress || 0));
              updateProgress(p);
              console.log(`üìà Mediabunny progress (worker): ${(p * 100).toFixed(1)}%`);
            } else if (type === 'done') {
              const buffer = ev.data.buffer; // ArrayBuffer (transferable)
              const blob = new Blob([buffer], { type: 'video/webm' });
              const elapsed = typeof ev.data.elapsedMs === 'number' ? ev.data.elapsedMs : (performance.now() - t0);
              handleReadyBlob(blob, elapsed);
              resolve();
            } else if (type === 'error') {
              console.error('Remux worker error:', ev.data.message);
              reject(new Error(ev.data.message));
            }
          };
          worker.onerror = (err) => reject(err);
          worker.postMessage({ chunks, mimeType });
        });
      } catch (err) {
        console.warn('Falling back to inline remux due to worker error:', err);
        const fixedBlob = await rebuildWebM(chunks);
        handleReadyBlob(fixedBlob, performance.now() - t0);
      } finally {
        if (worker) { worker.terminate(); worker = null; }
      }
    }

    function handleReadyBlob(fixedBlob, elapsedMs) {
      const url = URL.createObjectURL(fixedBlob);
      result.src = url;

      // –ê–≤—Ç–æ—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `screen-recording-${ts}.webm`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      console.log(`‚è±Ô∏è rebuildWebM –∑–∞–Ω—è–ª–æ ${elapsedMs.toFixed(1)} –º—Å`);
      console.log('‚úÖ –ì–æ—Ç–æ–≤–æ, —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω –∏ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞');
      // –°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
      updateProgress(1);
      setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }
  </script>
</body>
</html>
