<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny + Screen Recording Demo</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <style>
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress {
      position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.15);
    }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#4caf50,#2e7d32); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
  <!--
    –ü–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏ (npm install && npm run build) –ø–æ–¥–∫–ª—é—á–∞–µ–º dist/mediabunny.umd.js.
    –ì–ª–æ–±–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ window.Mediabunny
  -->
  
</head>
<body>
  <h2>üé¨ –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞ –∏ —Å–±–æ—Ä–∫–∏ WebM —Å Mediabunny (UMD)</h2>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
  <label style="margin-left:10px; font: 13px system-ui, sans-serif; display:none;">
    <input type="checkbox" id="saveToFile"> –°–æ—Ö—Ä–∞–Ω—è—Ç—å –Ω–∞–ø—Ä—è–º—É—é –≤ —Ñ–∞–π–ª (Chrome/Edge)
  </label>

  <div id="recInfo" style="display:none; margin: 0 10px; font: 13px system-ui, sans-serif; color:#b71c1c;">
    <span style="display:inline-block; width:10px; height:10px; background:#e53935; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>

  <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–º –ø–ª–µ–µ—Ä–µ, —ç–∫–æ–Ω–æ–º–∏–º –ø–∞–º—è—Ç—å -->

  <script>
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');

    let recorder, chunks = [];
    let recTimerId = null;
    let recStartMs = 0;
    let worker = null;
    let fsWritable = null; // FileSystemWritableFileStream
    const SAVE_STREAM_THRESHOLD = 500 * 1024 * 1024; // ~500 MB

    async function startRecording() {
      // –ó–∞—Ö–≤–∞—Ç —ç–∫—Ä–∞–Ω–∞ + —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –∑–≤—É–∫–∞ (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º)
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      chunks = [];

      recorder.ondataavailable = e => {
        if (e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstop = async () => {
        console.log("‚è≥ –ü–µ—Ä–µ—Å–±–æ—Ä–∫–∞ WebM (remux) –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ...");
        progressEl.style.display = '';
        progressTextEl.style.display = '';
        updateProgress(0);

        const t0 = performance.now();

        // –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º Web Worker; –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º –ø—Ä—è–º–æ–π –∑–∞–ø–∏—Å–∏ ‚Äî —Å—Ç—Ä–∏–º–∏–º –≤ —Ñ–∞–π–ª
        if (window.Worker) {
          const streamToFile = !!(fsWritable && window.showSaveFilePicker);
          await remuxInWorker(chunks, 'video/webm', t0, streamToFile);
        } else {
          const fixedBlob = await rebuildWebM(chunks);
          handleReadyBlob(fixedBlob, performance.now() - t0);
        }
      };

      // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç —à–∞—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ UI –±—Ä–∞—É–∑–µ—Ä–∞, –∑–∞–≤–µ—Ä—à–∏–º –∑–∞–ø–∏—Å—å
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };

      recorder.start(1000); // –ø–∏—Å–∞—Ç—å —á–∞–Ω–∫–∞–º–∏ –ø–æ 1—Å
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∏ –∏ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ç–∞–π–º–µ—Ä
      recStartMs = performance.now();
      document.getElementById('recInfo').style.display = '';
      updateRecTime(0);
      recTimerId = setInterval(() => {
        const ms = performance.now() - recStartMs;
        updateRecTime(ms);
      }, 250);
    }

    async function stopRecording() {
      // –ê–≤—Ç–æ–≤—ã–±–æ—Ä –ø–æ—Ç–æ–∫–æ–≤–æ–π –∑–∞–ø–∏—Å–∏ –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω FS API
      const approxSize = (chunks || []).reduce((s, b) => s + (b?.size || 0), 0);
      const wantStream = (document.getElementById('saveToFile').checked || approxSize > SAVE_STREAM_THRESHOLD);
      if (wantStream && window.showSaveFilePicker && !fsWritable) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm`,
            types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }]
          });
          fsWritable = await handle.createWritable();
        } catch (e) {
          console.warn('–í—ã–±–æ—Ä —Ñ–∞–π–ª–∞ –æ—Ç–º–µ–Ω—ë–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ FS API:', e);
        }
      }
      recorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (preview.srcObject) {
        preview.srcObject.getTracks().forEach(t => t.stop());
        preview.srcObject = null;
      }

      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';
    }

    async function rebuildWebM(chunks) {
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;

      const fullBlob = new Blob(chunks, { type: 'video/webm' });
      const input = new Input({ source: new BlobSource(fullBlob), formats: [WEBM] });

      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });

      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => {
        const percent = Math.max(0, Math.min(1, p));
        updateProgress(percent);
        console.log(`üìà Mediabunny progress: ${(percent * 100).toFixed(1)}%`);
      };
      await conversion.execute();

      const buffer = target.buffer;
      return new Blob([buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }

    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    async function remuxInWorker(chunks, mimeType, t0, streamToFile) {
      try {
        if (worker) { worker.terminate(); worker = null; }
        worker = new Worker('remux.worker.js');
        await new Promise((resolve, reject) => {
          worker.onmessage = async (ev) => {
            const { type } = ev.data || {};
            if (type === 'progress') {
              const p = Math.max(0, Math.min(1, ev.data.progress || 0));
              updateProgress(p);
              console.log(`üìà Mediabunny progress (worker): ${(p * 100).toFixed(1)}%`);
            } else if (type === 'done') {
              const elapsed = typeof ev.data.elapsedMs === 'number' ? ev.data.elapsedMs : (performance.now() - t0);
              if (ev.data.streamed) {
                try { if (fsWritable) await fsWritable.close(); } catch (e) {}
                fsWritable = null;
                console.log(`‚è±Ô∏è rebuildWebM –∑–∞–Ω—è–ª–æ ${elapsed.toFixed(1)} –º—Å`);
                console.log('‚úÖ –ì–æ—Ç–æ–≤–æ, —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
                updateProgress(1);
                setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
                resolve();
              } else {
                const buffer = ev.data.buffer; // ArrayBuffer (transferable)
                const blob = new Blob([buffer], { type: 'video/webm' });
                handleReadyBlob(blob, elapsed);
                resolve();
              }
            } else if (type === 'error') {
              console.error('Remux worker error:', ev.data.message);
              reject(new Error(ev.data.message));
            }
          };
          worker.onerror = (err) => reject(err);

          if (streamToFile) {
            if (!fsWritable) { reject(new Error('No writable handle')); return; }
            const channel = new MessageChannel();
            channel.port1.onmessage = async (msg) => {
              const d = msg.data || {};
              try {
                if (d.type === 'write') {
                  const u8 = new Uint8Array(d.data);
                  await fsWritable.write(u8);
                  channel.port1.postMessage({ type: 'ack', id: d.id });
                } else if (d.type === 'close') {
                  await fsWritable.close();
                  fsWritable = null;
                  channel.port1.postMessage({ type: 'ack', id: d.id });
                } else if (d.type === 'abort') {
                  try { await fsWritable.abort?.(); } catch (_) {}
                  try { await fsWritable.close(); } catch (_) {}
                  fsWritable = null;
                  channel.port1.postMessage({ type: 'ack', id: d.id });
                }
              } catch (err) {
                channel.port1.postMessage({ type: 'nack', id: d.id, message: String(err) });
              }
            };
            worker.postMessage({ mode: 'stream', chunks, mimeType, port: channel.port2 }, [channel.port2]);
          } else {
            worker.postMessage({ mode: 'buffer', chunks, mimeType });
          }
        });
      } catch (err) {
        console.warn('Worker remux error:', err);
        // –ï—Å–ª–∏ —É–ø—ë—Ä–ª–∏—Å—å –≤ –ø–∞–º—è—Ç—å –∏ –µ—Å—Ç—å FS API ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º –ø–æ—Ç–æ–∫–æ–≤—É—é –∑–∞–ø–∏—Å—å
        if (!streamToFile && window.showSaveFilePicker) {
          try {
            if (!fsWritable) {
              const handle = await window.showSaveFilePicker({
                suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm`,
                types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }]
              });
              fsWritable = await handle.createWritable();
            }
            return await remuxInWorker(chunks, mimeType, t0, true);
          } catch (e) {
            console.warn('Stream-to-file fallback failed or canceled:', e);
          }
        }
        // –§–æ–ª–±—ç–∫: inline —Ä–µ–º–∞–∫—Å (–º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –º–Ω–æ–≥–æ –ø–∞–º—è—Ç–∏)
        try {
          const fixedBlob = await rebuildWebM(chunks);
          handleReadyBlob(fixedBlob, performance.now() - t0);
        } catch (e2) {
          console.error('Inline remux failed:', e2);
          updateProgress(0);
          progressEl.style.display = 'none';
          progressTextEl.style.display = 'none';
          alert('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∑–∞–ø–∏—Å—å –∏–∑-–∑–∞ –Ω–µ—Ö–≤–∞—Ç–∫–∏ –ø–∞–º—è—Ç–∏. –û—Ç–∫—Ä–æ–π—Ç–µ –≤ Chrome –∏ –≤–∫–ª—é—á–∏—Ç–µ –ø–æ—Ç–æ–∫–æ–≤–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ.');
        }
      } finally {
        if (worker) { worker.terminate(); worker = null; }
      }
    }

    function handleReadyBlob(fixedBlob, elapsedMs) {
      // –û—á–∏—Å—Ç–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —á–∞–Ω–∫–∏, —á—Ç–æ–±—ã –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–∞–º—è—Ç—å
      for (let i = 0; i < chunks.length; i++) chunks[i] = null;
      chunks.length = 0;

      const url = URL.createObjectURL(fixedBlob);

      // –ê–≤—Ç–æ—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–±–µ–∑ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø–ª–µ–µ—Ä–µ)
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `screen-recording-${ts}.webm`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);

      console.log(`‚è±Ô∏è rebuildWebM –∑–∞–Ω—è–ª–æ ${elapsedMs.toFixed(1)} –º—Å`);
      console.log('‚úÖ –ì–æ—Ç–æ–≤–æ, —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω –∏ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞');
      // –°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
      updateProgress(1);
      setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }
  </script>
</body>
</html>
