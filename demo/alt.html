<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny Demo ‚Äî –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <script src="./idb-recorder.js"></script>
  <style>
    body { font: 14px/1.4 system-ui, sans-serif; }
    .nav { margin: 10px; }
    .nav a { margin-right: 12px; }
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress { position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#1976d2,#1565c0); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
</head>
<body>
  <div class="nav">
    <a href="./index.html">–ì–ª–∞–≤–Ω–∞—è</a>
    <a href="./alt.html"><strong>–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è</strong></a>
  </div>

  <h2>üé¨ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: –∑–∞–ø–∏—Å—å –∏ —Ä–µ–º–∞–∫—Å WebM</h2>

  <div style="margin:10px 0; padding:8px; background:#f5f5f5; border-radius:6px;">
    <strong>–û—Ç–ª–∞–¥–∫–∞ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤</strong><br>
    <label>
      <input type="checkbox" id="debugEnable"> –í–∫–ª—é—á–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ (–ø–æ–≤—Ç–æ—Ä—è–µ–º –ø–µ—Ä–≤—ã–π —á–∞–Ω–∫)
    </label>
    <div style="margin-top:6px;">
      –†–∞–∑–º–µ—Ä, –ú–ë: <input id="debugMB" type="number" min="0" step="100" value="0" style="width:100px;"> 
      <small>(–ø—Ä–∏–º–µ—Ä: 1000, 4000, 10000)</small>
    </div>
  </div>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

  <div id="recInfo" style="display:none; margin: 0 10px; color:#0d47a1;">
    <span style="display:inline-block; width:10px; height:10px; background:#1e88e5; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>

  <script>
    // –ü—Ä–æ—Å—Ç–∞—è –æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ —Ç–µ–∫—É—â–µ–π –ª–æ–≥–∏–∫–æ–π –∏–∑ index.html ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ helper'—ã
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');

    let recorder; let recTimerId = null; let recStartMs = 0; let fsWritable = null; let idbWriter = null; let currentSessionId = null;
    let firstChunkBlob = null; // –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–∞

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p || 0));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }
    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    async function startRecording() {
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      try { idbWriter = new IDBWriter(); idbRequestPersistence?.(); currentSessionId = await idbWriter.start({ filenameBase: 'screen-recording', mimeType: 'video/webm', roomId: undefined }); } catch (_) { idbWriter = null; currentSessionId = null; }
      recorder.ondataavailable = e => {
        if (e.data && e.data.size > 0) {
          if (!firstChunkBlob) firstChunkBlob = e.data;
          try { idbWriter?.enqueue(e.data); } catch (_) {}
        }
      };
      recorder.onstop = async () => {
        progressEl.style.display = ''; progressTextEl.style.display = ''; updateProgress(0);
        const t0 = performance.now();
        const debugEnabled = document.getElementById('debugEnable').checked;
        const debugMB = Number(document.getElementById('debugMB').value || 0);
        if (debugEnabled && debugMB > 0) {
          try {
            if (fsWritable) {
              await remuxDebugFromIDBToFile(currentSessionId, debugMB, 'video/webm', fsWritable);
            } else {
              const blob = await remuxDebugFromIDBToBlob(currentSessionId, debugMB, 'video/webm');
              handleReadyBlob(blob, performance.now() - t0);
            }
          } catch (e) {
            console.warn('Debug remux failed, fallback to IDB path:', e);
            if (fsWritable) { try { await fsWritable.close(); } catch (_) {} }
            await fallbackFromIDB();
          }
        } else if (fsWritable && currentSessionId) {
          try { await remuxToFileFromIDB(currentSessionId, 'video/webm', t0, fsWritable); }
          catch (e) {
            console.warn('Stream-to-file failed on alt page:', e);
            try { await fsWritable.close(); } catch (_) {}
            fsWritable = null;
            await fallbackFromIDB();
          } finally { fsWritable = null; }
        } else {
          await fallbackFromIDB();
        }
      };
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };
      recorder.start(1000);
      startBtn.disabled = true; stopBtn.disabled = false;
      recStartMs = performance.now(); document.getElementById('recInfo').style.display = '';
      updateRecTime(0); recTimerId = setInterval(() => updateRecTime(performance.now() - recStartMs), 250);
    }
    async function stopRecording() {
      if (window.showSaveFilePicker && !fsWritable) {
        try { const handle = await window.showSaveFilePicker({ suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm`, types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }] }); fsWritable = await handle.createWritable(); try { await fsWritable.truncate(0); } catch(_) {} } catch(e) { console.warn('FS API pick cancelled/failed:', e); }
      }
      recorder.stop(); startBtn.disabled = false; stopBtn.disabled = true;
      if (preview.srcObject) { preview.srcObject.getTracks().forEach(t => t.stop()); preview.srcObject = null; }
      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';
      try { await idbWriter?.stop(); } catch(_) {}
      idbWriter = null;
    }
    function handleReadyBlob(fixedBlob, elapsedMs) {
      const url = URL.createObjectURL(fixedBlob);
      const a = Object.assign(document.createElement('a'), { href: url, download: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm` });
      document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(url), 1000);
      updateProgress(1); setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }
    async function fallbackFromIDB() {
      const fullBlob = await buildBlobFromIDB(currentSessionId);
      const fixedBlob = await rebuildBlobWebM(fullBlob);
      handleReadyBlob(fixedBlob, 0);
    }
    async function buildBlobFromIDB(sessionId) {
      const db = await idbOpenDB();
      const rows = await new Promise((res, rej) => { const tx = db.transaction('chunks','readonly'); const idx = tx.objectStore('chunks').index('bySession'); const req = idx.getAll(IDBKeyRange.only(sessionId)); req.onsuccess = () => res(req.result.sort((a,b)=>a.seq-b.seq)); req.onerror = () => rej(req.error); });
      const parts = rows.map((r) => r.blob || new Blob([r.ab], { type: 'video/webm' }));
      return new Blob(parts, { type: 'video/webm' });
    }
    async function remuxToFileFromIDB(sessionId, mimeType, t0, writable) {
      const { Input, Output, WebMOutputFormat, StreamTarget, ReadableStreamSource, WEBM, Conversion } = window.Mediabunny;
      try { await writable.truncate?.(0); } catch(_) {}
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => { const tx = db.transaction('sessions','readonly'); const r = tx.objectStore('sessions').get(sessionId); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
      const expectedCount = sess?.chunkCount ?? null;
      let nextSeq = 0; let reachedEnd = false;
      const stream = new ReadableStream({
        async pull(controller) {
          if (reachedEnd) { controller.close(); return; }
          try {
            if (expectedCount !== null && nextSeq >= expectedCount) { reachedEnd = true; controller.close(); return; }
            const tx1 = db.transaction('chunks','readonly'); const store1 = tx1.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store1.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (row) { const blob = row.blob || new Blob([row.ab], { type: mimeType }); const ab = await blob.arrayBuffer(); controller.enqueue(new Uint8Array(ab)); nextSeq = (row.seq || nextSeq) + 1; return; }
            const tx2 = db.transaction('chunks','readonly'); const store2 = tx2.objectStore('chunks');
            const range = IDBKeyRange.bound([sessionId, nextSeq], [sessionId, Number.MAX_SAFE_INTEGER]);
            const req = store2.openCursor(range);
            const cursor = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error); });
            if (!cursor) { reachedEnd = true; controller.close(); return; }
            const row2 = cursor.value; const blob2 = row2.blob || new Blob([row2.ab], { type: mimeType });
            const ab2 = await blob2.arrayBuffer(); controller.enqueue(new Uint8Array(ab2)); nextSeq = (row2.seq || nextSeq) + 1;
          } catch (e) { controller.error(e); }
        }
      });
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: 64 * 1024 * 1024 }), formats: [WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      try { await writable.close(); } catch(_) {}
    }

    // ==== –û—Ç–ª–∞–¥–∫–∞: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—É—Ç—ë–º –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –≤—Å–µ–π —Å–µ—Å—Å–∏–∏ –∏–∑ IDB ====
    async function remuxDebugFromIDBToFile(sessionId, sizeMB, mimeType, writable) {
      const { Input, Output, WebMOutputFormat, StreamTarget, ReadableStreamSource, WEBM, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const db = await idbOpenDB();
      let produced = 0;
      let nextSeq = 0;
      const stream = new ReadableStream({
        async pull(controller) {
          if (produced >= targetBytes) { controller.close(); return; }
          // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—á–Ω—ã–π seq; –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π —Ü–∏–∫–ª —Å 0
          const tx = db.transaction('chunks','readonly');
          const store = tx.objectStore('chunks');
          let row = await new Promise((res, rej) => { const g = store.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
          if (!row) {
            nextSeq = 0;
            const tx2 = db.transaction('chunks','readonly');
            const store2 = tx2.objectStore('chunks');
            row = await new Promise((res, rej) => { const g = store2.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) { controller.close(); return; }
          }
          const blob = row.blob || new Blob([row.ab], { type: mimeType });
          const remaining = targetBytes - produced;
          const slice = remaining < blob.size ? blob.slice(0, remaining) : blob;
          const ab = await slice.arrayBuffer();
          controller.enqueue(new Uint8Array(ab));
          produced += ab.byteLength;
          nextSeq = (row.seq || nextSeq) + 1;
        }
      });
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: 64 * 1024 * 1024 }), formats: [WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      try { await writable.close(); } catch(_) {}
    }

    async function remuxDebugFromIDBToBlob(sessionId, sizeMB, mimeType) {
      const { Input, Output, WebMOutputFormat, BufferTarget, ReadableStreamSource, WEBM, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const db = await idbOpenDB();
      let produced = 0; let nextSeq = 0;
      const stream = new ReadableStream({
        async pull(controller) {
          if (produced >= targetBytes) { controller.close(); return; }
          const tx = db.transaction('chunks','readonly');
          const store = tx.objectStore('chunks');
          let row = await new Promise((res, rej) => { const g = store.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
          if (!row) {
            nextSeq = 0;
            const tx2 = db.transaction('chunks','readonly');
            const store2 = tx2.objectStore('chunks');
            row = await new Promise((res, rej) => { const g = store2.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) { controller.close(); return; }
          }
          const blob = row.blob || new Blob([row.ab], { type: mimeType });
          const remaining = targetBytes - produced;
          const slice = remaining < blob.size ? blob.slice(0, remaining) : blob;
          const ab = await slice.arrayBuffer();
          controller.enqueue(new Uint8Array(ab));
          produced += ab.byteLength;
          nextSeq = (row.seq || nextSeq) + 1;
        }
      });
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: 64 * 1024 * 1024 }), formats: [WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      return new Blob([target.buffer], { type: 'video/webm' });
    }
    async function rebuildBlobWebM(blob) {
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;
      const input = new Input({ source: new BlobSource(blob), formats: [WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      return new Blob([target.buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording; stopBtn.onclick = stopRecording;
  </script>
</body>
</html>
