<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny Demo ‚Äî –û—Ç–ª–∞–¥–∫–∞</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <script src="./idb-recorder.js"></script>
  <style>
    body { font: 14px/1.4 system-ui, sans-serif; }
    .nav { margin: 10px; }
    .nav a { margin-right: 12px; }
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress { position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#1976d2,#1565c0); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
</head>
<body>
  <div class="nav">
    <a href="./index.html">–ì–ª–∞–≤–Ω–∞—è</a>
    <a href="./alt.html"><strong>–û—Ç–ª–∞–¥–∫–∞</strong></a>
  </div>

  <h2>üé¨ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: –∑–∞–ø–∏—Å—å –∏ —Ä–µ–º–∞–∫—Å WebM</h2>

  <div style="margin:10px 0; padding:8px; background:#f5f5f5; border-radius:6px;">
    <strong>–û—Ç–ª–∞–¥–∫–∞ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤</strong><br>
    <label>
      <input type="checkbox" id="debugEnable" checked disabled> –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –≤–∫–ª—é—á–µ–Ω–∞
    </label>
    <div style="margin-top:6px;">
      –†–∞–∑–º–µ—Ä, –ú–ë: <input id="debugMB" type="number" min="0" step="100" value="0" style="width:100px;"> 
      <small>(–ø—Ä–∏–º–µ—Ä: 1000, 4000, 10000)</small>
    </div>
  </div>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
  <label style="margin-left:10px; font: 13px system-ui, sans-serif;">
    –ö–æ–¥–µ–∫:
    <select id="codecSelect">
      <option value="auto" selected>–ê–≤—Ç–æ (–ª—É—á—à–∏–π –¥–æ—Å—Ç—É–ø–Ω—ã–π)</option>
      <option value="video/webm; codecs=vp9,opus">WebM: VP9 + Opus</option>
      <option value="video/webm; codecs=vp8,opus">WebM: VP8 + Opus</option>
      <option value="video/webm">WebM (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)</option>
      <option value="video/mp4">MP4 (H.264/AAC)</option>
    </select>
  </label>

  <div id="recInfo" style="display:none; margin: 0 10px; color:#0d47a1;">
    <span style="display:inline-block; width:10px; height:10px; background:#1e88e5; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>

  <div style="margin:10px 0;">
    <button id="procLastBtn">üíæ –°–æ–±—Ä–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–µ—Å—Å–∏—é –≤ —Ñ–∞–π–ª</button>
    <button id="procSelectedBtn">üìÇ –°–æ–±—Ä–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é —Å–µ—Å—Å–∏—é</button>
    <select id="sessionSelect" style="min-width:320px;"></select>
    <button id="refreshSessionsBtn">üîÑ</button>
  </div>

  <fieldset style="margin:10px 0; padding:8px; border:1px solid #ddd; border-radius:6px;">
    <legend>–í–∞—Ä–∏–∞–Ω—Ç—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏</legend>
    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
      <label>Cache (MB): <input id="optCacheMB" type="number" min="0" step="16" value="64" style="width:80px;"></label>
      <label>Prefetch: 
        <select id="optPrefetch">
          <option value="none">none</option>
          <option value="fileSystem" selected>fileSystem</option>
          <option value="network">network</option>
        </select>
      </label>
      <label><input id="optAudioTrans" type="checkbox"> Audio forceTranscode</label>
      <label><input id="optVideoTrans" type="checkbox"> Video forceTranscode</label>
      <label>Pad (MB, optional): <input id="optPadMB" type="number" min="0" step="100" value="0" style="width:100px;"></label>
    </div>
    <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
      <button id="btnSSFile">‚ñ∂ StreamSource ‚Üí —Ñ–∞–π–ª</button>
      <button id="btnSSBlob">‚¨á StreamSource ‚Üí Blob (—Å–∫–∞—á–∞—Ç—å)</button>
      <button id="btnRSFile">‚ñ∂ ReadableStreamSource (–∫—É—Ä—Å–æ—Ä) ‚Üí —Ñ–∞–π–ª</button>
    </div>
  </fieldset>

  <script>
    // –ü—Ä–æ—Å—Ç–∞—è –æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ —Ç–µ–∫—É—â–µ–π –ª–æ–≥–∏–∫–æ–π –∏–∑ index.html ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ helper'—ã
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');
    const procLastBtn = document.getElementById('procLastBtn');
    const procSelectedBtn = document.getElementById('procSelectedBtn');
    const sessionSelect = document.getElementById('sessionSelect');
    const refreshSessionsBtn = document.getElementById('refreshSessionsBtn');
    const optCacheMB = document.getElementById('optCacheMB');
    const optPrefetch = document.getElementById('optPrefetch');
    const optAudioTrans = document.getElementById('optAudioTrans');
    const optVideoTrans = document.getElementById('optVideoTrans');
    const optPadMB = document.getElementById('optPadMB');
    const btnSSFile = document.getElementById('btnSSFile');
    const btnSSBlob = document.getElementById('btnSSBlob');
    const btnRSFile = document.getElementById('btnRSFile');
    const codecSelect = document.getElementById('codecSelect');

    let recorder; let recTimerId = null; let recStartMs = 0; let fsWritable = null; let fsHandle = null; let idbWriter = null; let currentSessionId = null;
    let firstChunkBlob = null; // –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–∞

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p || 0));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }
    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    function updateCodecOptionsSupport() {
      if (!window.MediaRecorder) return;
      const opts = Array.from(codecSelect.options).filter(o => o.value !== 'auto');
      for (const o of opts) {
        try {
          const sup = MediaRecorder.isTypeSupported(o.value);
          o.disabled = !sup;
          o.textContent = o.textContent.replace(/ \(–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è\)$/,'') + (sup ? '' : ' (–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)');
        } catch (_) {
          o.disabled = true;
          o.textContent = o.textContent.replace(/ \(–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è\)$/,'') + ' (–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)';
        }
      }
    }
    function resolveMimeSelection() {
      const selected = codecSelect.value;
      const candidates = [
        'video/webm; codecs=vp9,opus',
        'video/webm; codecs=vp8,opus',
        'video/webm',
        'video/mp4'
      ];
      const tryList = selected === 'auto' ? candidates : [selected, ...candidates.filter(x => x !== selected)];
      for (const mt of tryList) { if (MediaRecorder.isTypeSupported(mt)) return mt; }
      return '';
    }

    async function startRecording() {
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;
      updateCodecOptionsSupport();
      const chosenMime = resolveMimeSelection();
      recorder = chosenMime ? new MediaRecorder(stream, { mimeType: chosenMime }) : new MediaRecorder(stream);
      try {
        idbWriter = new IDBWriter(); idbRequestPersistence?.();
        const sessMime = recorder.mimeType || chosenMime || 'video/webm';
        currentSessionId = await idbWriter.start({ filenameBase: 'screen-recording', mimeType: sessMime, roomId: undefined });
      } catch (_) { idbWriter = null; currentSessionId = null; }
      recorder.ondataavailable = e => {
        if (e.data && e.data.size > 0) {
          if (!firstChunkBlob) firstChunkBlob = e.data;
          try { idbWriter?.enqueue(e.data); } catch (err) { console.warn('IDB enqueue failed:', err); }
        }
      };
      recorder.onstop = async () => {
        progressEl.style.display = ''; progressTextEl.style.display = ''; updateProgress(0);
        const t0 = performance.now();
        const debugEnabled = document.getElementById('debugEnable').checked;
        const debugMB = Number(document.getElementById('debugMB').value || 0);
        if (debugEnabled && debugMB > 0) {
          try {
            if (!window.showSaveFilePicker) {
              alert('–î–ª—è –æ—Ç–ª–∞–¥–∫–∏ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ –Ω—É–∂–µ–Ω File System Access API (Chrome/Edge).');
              return;
            }
            if (!fsHandle) {
              const mime = recorder?.mimeType || 'video/webm';
              const isMp4 = /^video\/mp4/.test(mime);
              fsHandle = await window.showSaveFilePicker({
                suggestedName: `debug-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4 ? 'mp4' : 'webm'}`,
                types: [ isMp4 ? { description: 'MP4 Video', accept: { 'video/mp4': ['.mp4'] } } : { description: 'WebM Video', accept: { 'video/webm': ['.webm'] } } ]
              });
            }
            await remuxOnceToFileAndPad(currentSessionId, recorder?.mimeType || 'video/webm', fsHandle, debugMB);
          } catch (e) {
            console.warn('Debug remux to file failed:', e);
            alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –≤ —Ñ–∞–π–ª –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏.');
          }
        } else if (fsWritable && currentSessionId) {
          try { await remuxToFileFromIDB(currentSessionId, recorder?.mimeType || 'video/webm', t0, fsWritable); }
          catch (e) {
            console.warn('Stream-to-file failed on alt page:', e);
            try { await fsWritable.close(); } catch (_) {}
            fsWritable = null;
            await fallbackFromIDB();
          } finally { fsWritable = null; }
        } else {
          await fallbackFromIDB();
        }
      };
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };
      recorder.start(1000);
      startBtn.disabled = true; stopBtn.disabled = false;
      recStartMs = performance.now(); document.getElementById('recInfo').style.display = '';
      updateRecTime(0); recTimerId = setInterval(() => updateRecTime(performance.now() - recStartMs), 250);
    }
    async function stopRecording() {
      recorder.stop(); startBtn.disabled = false; stopBtn.disabled = true;
      if (preview.srcObject) { preview.srcObject.getTracks().forEach(t => t.stop()); preview.srcObject = null; }
      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';
      try { await idbWriter?.stop(); } catch(_) {}
      idbWriter = null;
    }

    async function loadSessionsIntoSelect() {
      try {
        sessionSelect.innerHTML = '';
        const sessions = await idbListSessions();
        sessions.sort((a,b)=> (b.startedAt||0) - (a.startedAt||0));
        for (const s of sessions) {
          const started = s.startedAt ? new Date(s.startedAt).toLocaleString() : '–Ω–µ—Ç –¥–∞—Ç—ã';
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = `${started} ‚Äî ${s.chunkCount||0} —á–∞–Ω–∫–æ–≤`;
          opt.dataset.mime = s.mimeType || 'video/webm';
          sessionSelect.appendChild(opt);
        }
      } catch (e) {
        console.warn('loadSessions failed', e);
      }
    }
    function handleReadyBlob(fixedBlob, elapsedMs) {
      const url = URL.createObjectURL(fixedBlob);
      const isMp4 = /^video\/mp4/.test(fixedBlob.type);
      const a = Object.assign(document.createElement('a'), { href: url, download: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4 ? 'mp4' : 'webm'}` });
      document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(url), 1000);
      updateProgress(1); setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }
    async function fallbackFromIDB() {
      const mt = recorder?.mimeType || 'video/webm';
      const fullBlob = await buildBlobFromIDB(currentSessionId, mt);
      const fixedBlob = await rebuildBlobWebM(fullBlob);
      handleReadyBlob(fixedBlob, 0);
    }
    async function buildBlobFromIDB(sessionId, mimeType) {
      const db = await idbOpenDB();
      const rows = await new Promise((res, rej) => { const tx = db.transaction('chunks','readonly'); const idx = tx.objectStore('chunks').index('bySession'); const req = idx.getAll(IDBKeyRange.only(sessionId)); req.onsuccess = () => res(req.result.sort((a,b)=>a.seq-b.seq)); req.onerror = () => rej(req.error); });
      const mt = mimeType || 'video/webm';
      const parts = rows.map((r) => r.blob || new Blob([r.ab], { type: mt }));
      return new Blob(parts, { type: mt });
    }
    async function remuxToFileFromIDB(sessionId, mimeType, t0, writable) {
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, StreamTarget, ReadableStreamSource, WEBM, MP4, Conversion } = window.Mediabunny;
      try { await writable.truncate?.(0); } catch(_) {}
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => { const tx = db.transaction('sessions','readonly'); const r = tx.objectStore('sessions').get(sessionId); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
      const expectedCount = sess?.chunkCount ?? null;
      let nextSeq = 0; let reachedEnd = false;
      const stream = new ReadableStream({
        async pull(controller) {
          if (reachedEnd) { controller.close(); return; }
          try {
            if (expectedCount !== null && nextSeq >= expectedCount) { reachedEnd = true; controller.close(); return; }
            const tx1 = db.transaction('chunks','readonly'); const store1 = tx1.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store1.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (row) { const blob = row.blob || new Blob([row.ab], { type: mimeType }); const ab = await blob.arrayBuffer(); controller.enqueue(new Uint8Array(ab)); nextSeq = (row.seq || nextSeq) + 1; return; }
            const tx2 = db.transaction('chunks','readonly'); const store2 = tx2.objectStore('chunks');
            const range = IDBKeyRange.bound([sessionId, nextSeq], [sessionId, Number.MAX_SAFE_INTEGER]);
            const req = store2.openCursor(range);
            const cursor = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error); });
            if (!cursor) { reachedEnd = true; controller.close(); return; }
            const row2 = cursor.value; const blob2 = row2.blob || new Blob([row2.ab], { type: mimeType });
            const ab2 = await blob2.arrayBuffer(); controller.enqueue(new Uint8Array(ab2)); nextSeq = (row2.seq || nextSeq) + 1;
          } catch (e) { controller.error(e); }
        }
      });
      const isMp4 = /^video\/mp4/.test(mimeType);
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: 64 * 1024 * 1024 }), formats: [isMp4 ? MP4 : WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output, audio: { forceTranscode: true } });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      try { await writable.close(); } catch(_) {}
    }

    // ==== –û—Ç–ª–∞–¥–∫–∞: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –Ω–∞ –±–∞–∑–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ StreamSource ====
    async function buildSessionIndex(sessionId, mimeType) {
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => { const tx = db.transaction('sessions','readonly'); const r = tx.objectStore('sessions').get(sessionId); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
      const count = sess?.chunkCount ?? null;
      if (!count || count <= 0) throw new Error('Session has no chunks');
      const sizes = new Array(count);
      let total = 0;
      for (let i = 0; i < count; i++) {
        const tx = db.transaction('chunks','readonly');
        const store = tx.objectStore('chunks');
        const row = await new Promise((res, rej) => { const g = store.get([sessionId, i]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
        if (!row) { sizes[i] = 0; continue; }
        const size = row.blob ? row.blob.size : (row.ab ? row.ab.byteLength : 0);
        sizes[i] = size;
        total += size;
      }
      if (total === 0) throw new Error('All chunks are empty');
      const prefix = new Array(count);
      let acc = 0; for (let i = 0; i < count; i++) { prefix[i] = acc; acc += sizes[i]; }
      return { db, count, sizes, prefix, totalSize: total };
    }

    // –û—Ç–ª–∞–¥–∫–∞: –æ–±—ã—á–Ω—ã–π —Ä–µ–º–∞–∫—Å 1—Ö —á–µ—Ä–µ–∑ StreamSource (–±–µ–∑ cache-miss), –∑–∞—Ç–µ–º –ø–∞–¥–¥–∏–Ω–≥ –¥–æ —Ü–µ–ª–µ–≤–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
    async function remuxOnceToFileAndPad(sessionId, mimeType, handle, sizeMB) {
      const { Input, Output, WebMOutputFormat, StreamTarget, StreamSource, WEBM, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const writable = await handle.createWritable({ keepExistingData: false });
      try { await writable.truncate(0); } catch(_) {}

      // –ü–∏—à–µ–º –Ω–∞–ø—Ä—è–º—É—é –≤ FileSystemWritableFileStream
      // –ü–æ—Å—Ç—Ä–æ–∏–º –∏–Ω–¥–µ–∫—Å –∏ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º –¥–æ—Å—Ç—É–ø–æ–º
      const { db, count, sizes, prefix, totalSize } = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => totalSize,
        read: async (start, end) => {
          const len = end - start; const out = new Uint8Array(len);
          let written = 0; let pos = start;
          while (written < len) {
            const { seq, chunkOffset } = locateChunkByOffset(prefix, sizes, pos);
            const tx = db.transaction('chunks','readonly'); const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const take = Math.min(blob.size - chunkOffset, len - written);
            const ab = await blob.slice(chunkOffset, chunkOffset + take).arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength; pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: 128 * 1024 * 1024,
        prefetchProfile: 'fileSystem'
      });
      const input = new Input({ source, formats: [WEBM] });
      // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º FileSystemWritableFileStream –≤–æ WritableStream –¥–ª—è StreamTarget
      const sink = new WritableStream({
        async write(chunk) {
          const data = chunk && chunk.data !== undefined ? chunk.data : chunk;
          const position = chunk && typeof chunk.position === 'number' ? chunk.position : undefined;
          let u8;
          if (data instanceof Uint8Array) u8 = data;
          else if (data?.buffer) u8 = new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength || data.length || 0);
          else if (data instanceof ArrayBuffer) u8 = new Uint8Array(data);
          else {
            const ab = await new Blob([data]).arrayBuffer();
            u8 = new Uint8Array(ab);
          }
          if (typeof position === 'number') {
            try { await writable.seek(position); } catch (_) {}
          }
          await writable.write(u8);
        },
        async close() {
          // –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ—Å–ª–µ –ø–∞–¥–¥–∏–Ω–≥–∞ –≤—Ä—É—á–Ω—É—é
        },
        async abort() {}
      }, { highWaterMark: 1 });
      const target = new StreamTarget(sink, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output, audio: { forceTranscode: true } });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();

      const padChunk = new Uint8Array(16 * 1024 * 1024);
      let remaining = targetBytes;
      while (remaining > 0) {
        const slice = remaining < padChunk.length ? padChunk.subarray(0, remaining) : padChunk;
        await writable.write(slice);
        remaining -= slice.length;
      }
      await writable.close();
    }

    function locateChunkByOffset(prefix, sizes, offset) {
      // binary search over prefix sums to find largest index with prefix[i] <= offset
      let lo = 0, hi = sizes.length - 1, ans = 0;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        if (prefix[mid] <= offset) { ans = mid; lo = mid + 1; } else { hi = mid - 1; }
      }
      const seq = ans;
      const chunkOffset = offset - prefix[seq];
      return { seq, chunkOffset };
    }

    async function remuxDebugFromIDBToFile(sessionId, sizeMB, mimeType, writable) {
      const { Input, Output, WebMOutputFormat, StreamTarget, StreamSource, WEBM, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const index = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => targetBytes,
        read: async (start, end) => {
          const len = end - start;
          const out = new Uint8Array(len);
          let written = 0;
          let pos = start;
          while (written < len) {
            const loopOffset = pos % index.totalSize;
            const { seq, chunkOffset } = locateChunkByOffset(index.prefix, index.sizes, loopOffset);
            const tx = index.db.transaction('chunks','readonly');
            const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk during debug read');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const maxFromChunk = Math.min(blob.size - chunkOffset, len - written);
            const slice = blob.slice(chunkOffset, chunkOffset + maxFromChunk);
            const ab = await slice.arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength;
            pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: 128 * 1024 * 1024,
        prefetchProfile: 'fileSystem'
      });
      const input = new Input({ source, formats: [WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output, audio: { forceTranscode: true } });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      try { await writable.close(); } catch(_) {}
    }

    async function remuxDebugFromIDBToBlob(sessionId, sizeMB, mimeType) {
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, BufferTarget, StreamSource, WEBM, MP4, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const index = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => targetBytes,
        read: async (start, end) => {
          const len = end - start;
          const out = new Uint8Array(len);
          let written = 0;
          let pos = start;
          while (written < len) {
            const loopOffset = pos % index.totalSize;
            const { seq, chunkOffset } = locateChunkByOffset(index.prefix, index.sizes, loopOffset);
            const tx = index.db.transaction('chunks','readonly');
            const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk during debug read');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const maxFromChunk = Math.min(blob.size - chunkOffset, len - written);
            const slice = blob.slice(chunkOffset, chunkOffset + maxFromChunk);
            const ab = await slice.arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength;
            pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: 128 * 1024 * 1024,
        prefetchProfile: 'fileSystem'
      });
      const isMp4 = /^video\/mp4/.test(mimeType);
      const input = new Input({ source, formats: [isMp4 ? MP4 : WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      return new Blob([target.buffer], { type: isMp4 ? 'video/mp4' : 'video/webm' });
    }
    async function rebuildBlobWebM(blob) {
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, BufferTarget, BlobSource, WEBM, MP4, Conversion } = window.Mediabunny;
      const isMp4 = /^video\/mp4/.test(blob.type);
      const input = new Input({ source: new BlobSource(blob), formats: [isMp4 ? MP4 : WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      return new Blob([target.buffer], { type: isMp4 ? 'video/mp4' : 'video/webm' });
    }

    // –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –∫–æ–¥–µ–∫–æ–≤
    updateCodecOptionsSupport();

    startBtn.onclick = startRecording; stopBtn.onclick = stopRecording;
    procLastBtn.onclick = async () => {
      try {
        const debugMB = Number(document.getElementById('debugMB').value||0);
        if (!debugMB || debugMB<=0) { alert('–£–∫–∞–∂–∏—Ç–µ —Ä–∞–∑–º–µ—Ä (–ú–ë) > 0'); return; }
        const sessions = await idbListSessions();
        if (!sessions || !sessions.length) { alert('–í IndexedDB –Ω–µ—Ç —Å–µ—Å—Å–∏–π'); return; }
        sessions.sort((a,b)=> (b.startedAt||0) - (a.startedAt||0));
        const s = sessions[0];
        if (!window.showSaveFilePicker) { alert('–ù—É–∂–µ–Ω File System Access API'); return; }
        {
          const mt = s.mimeType || 'video/webm';
          const isMp4 = /^video\/mp4/.test(mt);
          fsHandle = await window.showSaveFilePicker({ suggestedName: `debug-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4?'mp4':'webm'}`, types:[ isMp4 ? {description:'MP4', accept:{'video/mp4':['.mp4']}} : {description:'WebM', accept:{'video/webm':['.webm']}} ]});
          await remuxOnceToFileAndPad(s.id, mt, fsHandle, debugMB);
        }
        alert('–ì–æ—Ç–æ–≤–æ: —Ñ–∞–π–ª –∑–∞–ø–∏—Å–∞–Ω');
      } catch (e) { console.warn('procLast failed', e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–µ—Å—Å–∏—é'); }
    };
    procSelectedBtn.onclick = async () => {
      try {
        const debugMB = Number(document.getElementById('debugMB').value||0);
        if (!debugMB || debugMB<=0) { alert('–£–∫–∞–∂–∏—Ç–µ —Ä–∞–∑–º–µ—Ä (–ú–ë) > 0'); return; }
        const sel = sessionSelect.value;
        if (!sel) { alert('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Å—Å–∏—é'); return; }
        const mime = sessionSelect.options[sessionSelect.selectedIndex]?.dataset?.mime || 'video/webm';
        if (!window.showSaveFilePicker) { alert('–ù—É–∂–µ–Ω File System Access API'); return; }
        {
          const isMp4 = /^video\/mp4/.test(mime);
          fsHandle = await window.showSaveFilePicker({ suggestedName: `debug-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4?'mp4':'webm'}`, types:[ isMp4 ? {description:'MP4', accept:{'video/mp4':['.mp4']}} : {description:'WebM', accept:{'video/webm':['.webm']}} ]});
          await remuxOnceToFileAndPad(sel, mime, fsHandle, debugMB);
        }
        alert('–ì–æ—Ç–æ–≤–æ: —Ñ–∞–π–ª –∑–∞–ø–∏—Å–∞–Ω');
      } catch (e) { console.warn('procSelected failed', e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é —Å–µ—Å—Å–∏—é'); }
    };
    refreshSessionsBtn.onclick = loadSessionsIntoSelect;
    loadSessionsIntoSelect();

    // ====== –í–∞—Ä–∏–∞–Ω—Ç—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ ======
    btnSSFile.onclick = async () => {
      const sel = sessionSelect.value; if (!sel) { alert('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Å—Å–∏—é'); return; }
      const mime = sessionSelect.options[sessionSelect.selectedIndex]?.dataset?.mime || 'video/webm';
      if (!window.showSaveFilePicker) { alert('–ù—É–∂–µ–Ω File System Access API'); return; }
      const cacheMB = Math.max(0, Number(optCacheMB.value||0));
      const prefetch = optPrefetch.value;
      const forceAudio = !!optAudioTrans.checked;
      const forceVideo = !!optVideoTrans.checked;
      const padMB = Math.max(0, Number(optPadMB.value||0));
      const isMp4 = /^video\/mp4/.test(mime);
      const handle = await window.showSaveFilePicker({ suggestedName: `debug-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4?'mp4':'webm'}`, types: [ isMp4 ? { description:'MP4', accept: {'video/mp4':['.mp4']}} : { description:'WebM', accept: {'video/webm':['.webm']}} ] });
      await remuxSelected_StreamSource_toFile({ sessionId: sel, mimeType: mime, handle, cacheMB, prefetch, forceAudio, forceVideo, padMB });
      alert('–ì–æ—Ç–æ–≤–æ: —Ñ–∞–π–ª –∑–∞–ø–∏—Å–∞–Ω');
    };

    btnSSBlob.onclick = async () => {
      const sel = sessionSelect.value; if (!sel) { alert('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Å—Å–∏—é'); return; }
      const mime = sessionSelect.options[sessionSelect.selectedIndex]?.dataset?.mime || 'video/webm';
      const cacheMB = Math.max(0, Number(optCacheMB.value||0));
      const prefetch = optPrefetch.value;
      const forceAudio = !!optAudioTrans.checked;
      const forceVideo = !!optVideoTrans.checked;
      await remuxSelected_StreamSource_toBlob({ sessionId: sel, mimeType: mime, cacheMB, prefetch, forceAudio, forceVideo });
    };

    btnRSFile.onclick = async () => {
      const sel = sessionSelect.value; if (!sel) { alert('–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Å—Å–∏—é'); return; }
      const mime = sessionSelect.options[sessionSelect.selectedIndex]?.dataset?.mime || 'video/webm';
      if (!window.showSaveFilePicker) { alert('–ù—É–∂–µ–Ω File System Access API'); return; }
      const cacheMB = Math.max(0, Number(optCacheMB.value||0));
      const forceAudio = !!optAudioTrans.checked;
      const forceVideo = !!optVideoTrans.checked;
      const padMB = Math.max(0, Number(optPadMB.value||0));
      const isMp4_2 = /^video\/mp4/.test(mime);
      const handle = await window.showSaveFilePicker({ suggestedName: `debug-rs-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4_2?'mp4':'webm'}`, types: [ isMp4_2 ? { description:'MP4', accept: {'video/mp4':['.mp4']}} : { description:'WebM', accept: {'video/webm':['.webm']}} ] });
      await remuxSelected_ReadableStreamSource_toFile({ sessionId: sel, mimeType: mime, handle, cacheMB, forceAudio, forceVideo, padMB });
      alert('–ì–æ—Ç–æ–≤–æ: —Ñ–∞–π–ª –∑–∞–ø–∏—Å–∞–Ω');
    };

    // Implementations
    async function remuxSelected_StreamSource_toFile(opts) {
      const { sessionId, mimeType, handle, cacheMB, prefetch, forceAudio, forceVideo, padMB } = opts;
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, StreamTarget, StreamSource, WEBM, MP4, Conversion } = window.Mediabunny;
      const writable = await handle.createWritable({ keepExistingData: false });
      try { await writable.truncate(0); } catch(_) {}
      const { db, count, sizes, prefix, totalSize } = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => totalSize,
        read: async (start, end) => {
          const len = end - start; const out = new Uint8Array(len);
          let written = 0; let pos = start;
          while (written < len) {
            const { seq, chunkOffset } = locateChunkByOffset(prefix, sizes, pos);
            const tx = db.transaction('chunks','readonly'); const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const take = Math.min(blob.size - chunkOffset, len - written);
            const ab = await blob.slice(chunkOffset, chunkOffset + take).arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength; pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: Math.max(0, (cacheMB|0)) * 1024 * 1024,
        prefetchProfile: prefetch || 'none'
      });
      const isMp4 = /^video\/mp4/.test(mimeType);
      const input2 = new Input({ source, formats: [isMp4 ? MP4 : WEBM] });
      // Wrap file stream into WritableStream for StreamTarget
      const sink = new WritableStream({
        async write(chunk) {
          const data = chunk && chunk.data !== undefined ? chunk.data : chunk;
          const position = chunk && typeof chunk.position === 'number' ? chunk.position : undefined;
          let u8;
          if (data instanceof Uint8Array) u8 = data;
          else if (data?.buffer) u8 = new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength || data.length || 0);
          else if (data instanceof ArrayBuffer) u8 = new Uint8Array(data);
          else { const ab = await new Blob([data]).arrayBuffer(); u8 = new Uint8Array(ab); }
          if (typeof position === 'number') { try { await writable.seek(position); } catch(_) {} }
          await writable.write(u8);
        },
        async close() {}, async abort() {}
      }, { highWaterMark: 1 });
      const target = new StreamTarget(sink, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const convOpts = { input: input2, output };
      if (forceAudio) convOpts.audio = { forceTranscode: true };
      if (forceVideo) convOpts.video = { forceTranscode: true };
      const conversion = await Conversion.init(convOpts);
      conversion.onProgress = (p) => updateProgress(Math.max(0, Math.min(1, p || 0)));
      await conversion.execute();
      // pad
      const padBytes = Math.max(0, (padMB|0) * 1024 * 1024);
      if (padBytes > 0) {
        const padChunk = new Uint8Array(16 * 1024 * 1024);
        let remaining = padBytes;
        while (remaining > 0) { const slice = remaining < padChunk.length ? padChunk.subarray(0, remaining) : padChunk; await writable.write(slice); remaining -= slice.length; }
      }
      await writable.close();
    }

    async function remuxSelected_StreamSource_toBlob(opts) {
      const { sessionId, mimeType, cacheMB, prefetch, forceAudio, forceVideo } = opts;
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, BufferTarget, StreamSource, WEBM, MP4, Conversion } = window.Mediabunny;
      const { db, count, sizes, prefix, totalSize } = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => totalSize,
        read: async (start, end) => {
          const len = end - start; const out = new Uint8Array(len);
          let written = 0; let pos = start;
          while (written < len) {
            const { seq, chunkOffset } = locateChunkByOffset(prefix, sizes, pos);
            const tx = db.transaction('chunks','readonly'); const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const take = Math.min(blob.size - chunkOffset, len - written);
            const ab = await blob.slice(chunkOffset, chunkOffset + take).arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength; pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: Math.max(0, (cacheMB|0)) * 1024 * 1024,
        prefetchProfile: prefetch || 'none'
      });
      const isMp4 = /^video\/mp4/.test(mimeType);
      const input = new Input({ source, formats: [isMp4 ? MP4 : WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: isMp4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const convOpts = { input, output };
      if (forceAudio) convOpts.audio = { forceTranscode: true };
      if (forceVideo) convOpts.video = { forceTranscode: true };
      const conversion = await Conversion.init(convOpts);
      conversion.onProgress = (p) => updateProgress(Math.max(0, Math.min(1, p || 0)));
      await conversion.execute();
      const blob = new Blob([target.buffer], { type: mimeType });
      const isMp4_3 = /^video\/mp4/.test(mimeType);
      const a = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: `debug-${new Date().toISOString().replace(/[:.]/g,'-')}.${isMp4_3?'mp4':'webm'}` });
      document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
    }

    async function remuxSelected_ReadableStreamSource_toFile(opts) {
      const { sessionId, mimeType, handle, cacheMB, forceAudio, forceVideo, padMB } = opts;
      const { Input, Output, WebMOutputFormat, Mp4OutputFormat, StreamTarget, ReadableStreamSource, WEBM, MP4, Conversion } = window.Mediabunny;
      const writable = await handle.createWritable({ keepExistingData: false });
      try { await writable.truncate(0); } catch(_) {}
      const db = await idbOpenDB();
      let nextSeq = 0; let done = false;
      const stream = new ReadableStream({
        async pull(controller) {
          if (done) { controller.close(); return; }
          const tx = db.transaction('chunks','readonly'); const store = tx.objectStore('chunks');
          const row = await new Promise((res, rej) => { const g = store.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
          if (!row) { done = true; controller.close(); return; }
          const blob = row.blob || new Blob([row.ab], { type: mimeType });
          const ab = await blob.arrayBuffer(); controller.enqueue(new Uint8Array(ab));
          nextSeq = (row.seq || nextSeq) + 1;
        }
      });
      const isMp4_4 = /^video\/mp4/.test(mimeType);
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: Math.max(0,(cacheMB|0))*1024*1024 }), formats: [isMp4_4 ? MP4 : WEBM] });
      const sink = new WritableStream({
        async write(chunk) {
          const data = chunk && chunk.data !== undefined ? chunk.data : chunk;
          const position = chunk && typeof chunk.position === 'number' ? chunk.position : undefined;
          let u8;
          if (data instanceof Uint8Array) u8 = data; else if (data?.buffer) u8 = new Uint8Array(data.buffer, data.byteOffset||0, data.byteLength||data.length||0);
          else if (data instanceof ArrayBuffer) u8 = new Uint8Array(data); else { const ab = await new Blob([data]).arrayBuffer(); u8 = new Uint8Array(ab); }
          if (typeof position === 'number') { try { await writable.seek(position); } catch(_) {} }
          await writable.write(u8);
        }, async close() {}, async abort() {}
      }, { highWaterMark: 1 });
      const target = new StreamTarget(sink, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: isMp4_4 ? new Mp4OutputFormat() : new WebMOutputFormat(), target });
      const convOpts = { input, output };
      if (forceAudio) convOpts.audio = { forceTranscode: true };
      if (forceVideo) convOpts.video = { forceTranscode: true };
      const conversion = await Conversion.init(convOpts);
      conversion.onProgress = (p) => updateProgress(Math.max(0, Math.min(1, p || 0)));
      await conversion.execute();
      const padBytes = Math.max(0, (padMB|0) * 1024 * 1024);
      if (padBytes > 0) { const padChunk = new Uint8Array(16 * 1024 * 1024); let remaining = padBytes; while (remaining>0) { const slice = remaining<padChunk.length?padChunk.subarray(0,remaining):padChunk; await writable.write(slice); remaining-=slice.length; } }
      await writable.close();
    }
  </script>
</body>
</html>
