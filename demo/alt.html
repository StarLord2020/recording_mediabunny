<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Mediabunny Demo ‚Äî –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è</title>
  <script src="../dist/mediabunny.umd.js"></script>
  <script src="./idb-recorder.js"></script>
  <style>
    body { font: 14px/1.4 system-ui, sans-serif; }
    .nav { margin: 10px; }
    .nav a { margin-right: 12px; }
    video { width: 480px; margin: 10px; background: #000; }
    button { margin: 10px; padding: 8px 14px; }
    .progress { position: relative; width: 480px; height: 10px; background: #eee; margin: 10px; border-radius: 6px; overflow: hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .progress__bar { height: 100%; width: 0%; background: linear-gradient(90deg,#1976d2,#1565c0); transition: width 0.1s ease; }
    .progress__text { font: 12px system-ui, sans-serif; margin: 0 10px; color: #333; }
  </style>
</head>
<body>
  <div class="nav">
    <a href="./index.html">–ì–ª–∞–≤–Ω–∞—è</a>
    <a href="./alt.html"><strong>–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è</strong></a>
  </div>

  <h2>üé¨ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: –∑–∞–ø–∏—Å—å –∏ —Ä–µ–º–∞–∫—Å WebM</h2>

  <div style="margin:10px 0; padding:8px; background:#f5f5f5; border-radius:6px;">
    <strong>–û—Ç–ª–∞–¥–∫–∞ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤</strong><br>
    <label>
      <input type="checkbox" id="debugEnable"> –í–∫–ª—é—á–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ (–ø–æ–≤—Ç–æ—Ä—è–µ–º –ø–µ—Ä–≤—ã–π —á–∞–Ω–∫)
    </label>
    <div style="margin-top:6px;">
      –†–∞–∑–º–µ—Ä, –ú–ë: <input id="debugMB" type="number" min="0" step="100" value="0" style="width:100px;"> 
      <small>(–ø—Ä–∏–º–µ—Ä: 1000, 4000, 10000)</small>
    </div>
  </div>

  <video id="preview" autoplay muted></video><br>
  <button id="startBtn">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</button>
  <button id="stopBtn" disabled>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

  <div id="recInfo" style="display:none; margin: 0 10px; color:#0d47a1;">
    <span style="display:inline-block; width:10px; height:10px; background:#1e88e5; border-radius:50%; margin-right:6px; vertical-align:middle;"></span>
    –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å: <span id="recTime">0:00</span>
  </div>

  <div class="progress" id="progress" style="display:none">
    <div class="progress__bar" id="progressBar"></div>
  </div>
  <div class="progress__text" id="progressText" style="display:none">0%</div>

  <script>
    // –ü—Ä–æ—Å—Ç–∞—è –æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ —Ç–µ–∫—É—â–µ–π –ª–æ–≥–∏–∫–æ–π –∏–∑ index.html ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ helper'—ã
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const progressEl = document.getElementById('progress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');

    let recorder; let recTimerId = null; let recStartMs = 0; let fsWritable = null; let idbWriter = null; let currentSessionId = null;
    let firstChunkBlob = null; // –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–∞

    function updateProgress(p) {
      const clamped = Math.max(0, Math.min(1, p || 0));
      progressBarEl.style.width = `${(clamped*100).toFixed(1)}%`;
      progressTextEl.textContent = `${(clamped*100).toFixed(1)}%`;
    }
    function updateRecTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60).toString();
      const s = (totalSec % 60).toString().padStart(2,'0');
      document.getElementById('recTime').textContent = `${m}:${s}`;
    }

    async function startRecording() {
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      preview.srcObject = stream;
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      try { idbWriter = new IDBWriter(); idbRequestPersistence?.(); currentSessionId = await idbWriter.start({ filenameBase: 'screen-recording', mimeType: 'video/webm', roomId: undefined }); } catch (_) { idbWriter = null; currentSessionId = null; }
      recorder.ondataavailable = e => {
        if (e.data && e.data.size > 0) {
          if (!firstChunkBlob) firstChunkBlob = e.data;
          try { idbWriter?.enqueue(e.data); } catch (_) {}
        }
      };
      recorder.onstop = async () => {
        progressEl.style.display = ''; progressTextEl.style.display = ''; updateProgress(0);
        const t0 = performance.now();
        const debugEnabled = document.getElementById('debugEnable').checked;
        const debugMB = Number(document.getElementById('debugMB').value || 0);
        if (debugEnabled && debugMB > 0) {
          try {
            if (fsWritable) {
              await remuxDebugFromIDBToFile(currentSessionId, debugMB, 'video/webm', fsWritable);
            } else {
              const blob = await remuxDebugFromIDBToBlob(currentSessionId, debugMB, 'video/webm');
              handleReadyBlob(blob, performance.now() - t0);
            }
          } catch (e) {
            console.warn('Debug remux failed, fallback to IDB path:', e);
            if (fsWritable) { try { await fsWritable.close(); } catch (_) {} }
            await fallbackFromIDB();
          }
        } else if (fsWritable && currentSessionId) {
          try { await remuxToFileFromIDB(currentSessionId, 'video/webm', t0, fsWritable); }
          catch (e) {
            console.warn('Stream-to-file failed on alt page:', e);
            try { await fsWritable.close(); } catch (_) {}
            fsWritable = null;
            await fallbackFromIDB();
          } finally { fsWritable = null; }
        } else {
          await fallbackFromIDB();
        }
      };
      const [vtrack] = stream.getVideoTracks();
      if (vtrack) vtrack.onended = () => { if (recorder && recorder.state === 'recording') stopRecording(); };
      recorder.start(1000);
      startBtn.disabled = true; stopBtn.disabled = false;
      recStartMs = performance.now(); document.getElementById('recInfo').style.display = '';
      updateRecTime(0); recTimerId = setInterval(() => updateRecTime(performance.now() - recStartMs), 250);
    }
    async function stopRecording() {
      if (window.showSaveFilePicker && !fsWritable) {
        try { const handle = await window.showSaveFilePicker({ suggestedName: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm`, types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }] }); fsWritable = await handle.createWritable(); try { await fsWritable.truncate(0); } catch(_) {} } catch(e) { console.warn('FS API pick cancelled/failed:', e); }
      }
      recorder.stop(); startBtn.disabled = false; stopBtn.disabled = true;
      if (preview.srcObject) { preview.srcObject.getTracks().forEach(t => t.stop()); preview.srcObject = null; }
      if (recTimerId) { clearInterval(recTimerId); recTimerId = null; }
      document.getElementById('recInfo').style.display = 'none';
      try { await idbWriter?.stop(); } catch(_) {}
      idbWriter = null;
    }
    function handleReadyBlob(fixedBlob, elapsedMs) {
      const url = URL.createObjectURL(fixedBlob);
      const a = Object.assign(document.createElement('a'), { href: url, download: `screen-recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm` });
      document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(url), 1000);
      updateProgress(1); setTimeout(() => { progressEl.style.display = 'none'; progressTextEl.style.display = 'none'; updateProgress(0); }, 600);
    }
    async function fallbackFromIDB() {
      const fullBlob = await buildBlobFromIDB(currentSessionId);
      const fixedBlob = await rebuildBlobWebM(fullBlob);
      handleReadyBlob(fixedBlob, 0);
    }
    async function buildBlobFromIDB(sessionId) {
      const db = await idbOpenDB();
      const rows = await new Promise((res, rej) => { const tx = db.transaction('chunks','readonly'); const idx = tx.objectStore('chunks').index('bySession'); const req = idx.getAll(IDBKeyRange.only(sessionId)); req.onsuccess = () => res(req.result.sort((a,b)=>a.seq-b.seq)); req.onerror = () => rej(req.error); });
      const parts = rows.map((r) => r.blob || new Blob([r.ab], { type: 'video/webm' }));
      return new Blob(parts, { type: 'video/webm' });
    }
    async function remuxToFileFromIDB(sessionId, mimeType, t0, writable) {
      const { Input, Output, WebMOutputFormat, StreamTarget, ReadableStreamSource, WEBM, Conversion } = window.Mediabunny;
      try { await writable.truncate?.(0); } catch(_) {}
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => { const tx = db.transaction('sessions','readonly'); const r = tx.objectStore('sessions').get(sessionId); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
      const expectedCount = sess?.chunkCount ?? null;
      let nextSeq = 0; let reachedEnd = false;
      const stream = new ReadableStream({
        async pull(controller) {
          if (reachedEnd) { controller.close(); return; }
          try {
            if (expectedCount !== null && nextSeq >= expectedCount) { reachedEnd = true; controller.close(); return; }
            const tx1 = db.transaction('chunks','readonly'); const store1 = tx1.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store1.get([sessionId, nextSeq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (row) { const blob = row.blob || new Blob([row.ab], { type: mimeType }); const ab = await blob.arrayBuffer(); controller.enqueue(new Uint8Array(ab)); nextSeq = (row.seq || nextSeq) + 1; return; }
            const tx2 = db.transaction('chunks','readonly'); const store2 = tx2.objectStore('chunks');
            const range = IDBKeyRange.bound([sessionId, nextSeq], [sessionId, Number.MAX_SAFE_INTEGER]);
            const req = store2.openCursor(range);
            const cursor = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error); });
            if (!cursor) { reachedEnd = true; controller.close(); return; }
            const row2 = cursor.value; const blob2 = row2.blob || new Blob([row2.ab], { type: mimeType });
            const ab2 = await blob2.arrayBuffer(); controller.enqueue(new Uint8Array(ab2)); nextSeq = (row2.seq || nextSeq) + 1;
          } catch (e) { controller.error(e); }
        }
      });
      const input = new Input({ source: new ReadableStreamSource(stream, { maxCacheSize: 64 * 1024 * 1024 }), formats: [WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      try { await writable.close(); } catch(_) {}
    }

    // ==== –û—Ç–ª–∞–¥–∫–∞: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –±–æ–ª—å—à–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –Ω–∞ –±–∞–∑–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ StreamSource ====
    async function buildSessionIndex(sessionId, mimeType) {
      const db = await idbOpenDB();
      const sess = await new Promise((res, rej) => { const tx = db.transaction('sessions','readonly'); const r = tx.objectStore('sessions').get(sessionId); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
      const count = sess?.chunkCount ?? null;
      if (!count || count <= 0) throw new Error('Session has no chunks');
      const sizes = new Array(count);
      let total = 0;
      for (let i = 0; i < count; i++) {
        const tx = db.transaction('chunks','readonly');
        const store = tx.objectStore('chunks');
        const row = await new Promise((res, rej) => { const g = store.get([sessionId, i]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
        if (!row) { sizes[i] = 0; continue; }
        const size = row.blob ? row.blob.size : (row.ab ? row.ab.byteLength : 0);
        sizes[i] = size;
        total += size;
      }
      if (total === 0) throw new Error('All chunks are empty');
      const prefix = new Array(count);
      let acc = 0; for (let i = 0; i < count; i++) { prefix[i] = acc; acc += sizes[i]; }
      return { db, count, sizes, prefix, totalSize: total };
    }

    function locateChunkByOffset(prefix, sizes, offset) {
      // binary search over prefix sums to find largest index with prefix[i] <= offset
      let lo = 0, hi = sizes.length - 1, ans = 0;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        if (prefix[mid] <= offset) { ans = mid; lo = mid + 1; } else { hi = mid - 1; }
      }
      const seq = ans;
      const chunkOffset = offset - prefix[seq];
      return { seq, chunkOffset };
    }

    async function remuxDebugFromIDBToFile(sessionId, sizeMB, mimeType, writable) {
      const { Input, Output, WebMOutputFormat, StreamTarget, StreamSource, WEBM, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const index = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => targetBytes,
        read: async (start, end) => {
          const len = end - start;
          const out = new Uint8Array(len);
          let written = 0;
          let pos = start;
          while (written < len) {
            const loopOffset = pos % index.totalSize;
            const { seq, chunkOffset } = locateChunkByOffset(index.prefix, index.sizes, loopOffset);
            const tx = index.db.transaction('chunks','readonly');
            const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk during debug read');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const maxFromChunk = Math.min(blob.size - chunkOffset, len - written);
            const slice = blob.slice(chunkOffset, chunkOffset + maxFromChunk);
            const ab = await slice.arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength;
            pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: 128 * 1024 * 1024,
        prefetchProfile: 'fileSystem'
      });
      const input = new Input({ source, formats: [WEBM] });
      const target = new StreamTarget(writable, { chunked: true, chunkSize: 16 * 1024 * 1024 });
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      try { await writable.close(); } catch(_) {}
    }

    async function remuxDebugFromIDBToBlob(sessionId, sizeMB, mimeType) {
      const { Input, Output, WebMOutputFormat, BufferTarget, StreamSource, WEBM, Conversion } = window.Mediabunny;
      const targetBytes = Math.max(0, Math.floor(sizeMB * 1024 * 1024));
      if (targetBytes === 0) throw new Error('Target size must be > 0');
      const index = await buildSessionIndex(sessionId, mimeType);
      const source = new StreamSource({
        getSize: () => targetBytes,
        read: async (start, end) => {
          const len = end - start;
          const out = new Uint8Array(len);
          let written = 0;
          let pos = start;
          while (written < len) {
            const loopOffset = pos % index.totalSize;
            const { seq, chunkOffset } = locateChunkByOffset(index.prefix, index.sizes, loopOffset);
            const tx = index.db.transaction('chunks','readonly');
            const store = tx.objectStore('chunks');
            const row = await new Promise((res, rej) => { const g = store.get([sessionId, seq]); g.onsuccess = () => res(g.result); g.onerror = () => rej(g.error); });
            if (!row) throw new Error('Missing chunk during debug read');
            const blob = row.blob || new Blob([row.ab], { type: mimeType });
            const maxFromChunk = Math.min(blob.size - chunkOffset, len - written);
            const slice = blob.slice(chunkOffset, chunkOffset + maxFromChunk);
            const ab = await slice.arrayBuffer();
            out.set(new Uint8Array(ab), written);
            written += ab.byteLength;
            pos += ab.byteLength;
          }
          return out;
        },
        maxCacheSize: 128 * 1024 * 1024,
        prefetchProfile: 'fileSystem'
      });
      const input = new Input({ source, formats: [WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      return new Blob([target.buffer], { type: 'video/webm' });
    }
    async function rebuildBlobWebM(blob) {
      const { Input, Output, WebMOutputFormat, BufferTarget, BlobSource, WEBM, Conversion } = window.Mediabunny;
      const input = new Input({ source: new BlobSource(blob), formats: [WEBM] });
      const target = new BufferTarget();
      const output = new Output({ format: new WebMOutputFormat(), target });
      const conversion = await Conversion.init({ input, output });
      conversion.onProgress = (p) => { updateProgress(Math.max(0, Math.min(1, p || 0))); };
      await conversion.execute();
      return new Blob([target.buffer], { type: 'video/webm' });
    }

    startBtn.onclick = startRecording; stopBtn.onclick = stopRecording;
  </script>
</body>
</html>
