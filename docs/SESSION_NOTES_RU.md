Последнее состояние (коротко)

- Цель: собрать длинные записи WebM (десятки ГБ) из чанков IndexedDB, без упора в ОЗУ, с возможностью прямой записи в файл (FS API) и с fallback без FS API.
- Главная страница (`index.html`): рабочий вариант ремакса через StreamSource (random-access по чанкам IDB) + возможность обработать уже существующую сессию в файл. Прогресс: 1) Индексация (sizes/prefix) → 2) Байтовый прогресс конверсии.
- Отладочная (`alt.html`): набор режимов для тестов (StreamSource/ReadableStreamSource), запись в файл (исправлен `StreamTarget` → оборачиваем FileSystemWritableFileStream в WritableStream), паддинг до размеров.
- Страница сессий (`sessions.html`): работа только с существующими сессиями, 4 прогресс-бара (Индексация, Байтовый, Прогресс библиотеки, Финализация) и вывод итогового времени. Добавлен режим «скачать по частям ≈ N ГБ».
- Сервис (`services/remuxService.js`): переиспользуемые методы для любой страницы/проекта (листинг сессий, индексация, StreamSource, ремакс в файл/Blob, оконный ремакс).
- Лимит IDB на 10 сессий убран (чистка не выполняется автоматически).

Детали реализации

1) Поток данных (индексация + StreamSource)
   - Индекс строится один раз: sizes[] и prefix[] (суммы) для быстрого маппинга «смещение → (seq, offset)» без склейки в память.
   - StreamSource.read(start,end) читает только нужные фрагменты Blob из IDB и возвращает буфер; дополнительные буферы небольшие, память не растёт.
   - Для очень длинных записей это значительно устойчивее, чем последовательный ReadableStreamSource с малым кешем (избегаем cache-miss).

2) Запись в файл (FS API)
   - На главной/alt: `StreamTarget` → (WritableStream) → FileSystemWritableFileStream. Для `StreamTarget` требуется WritableStream, поэтому FileSystemWritableFileStream оборачиваем в WritableStream-sink.
   - Без FS API (Firefox/Safari): прямой поток в файл недоступен; fallback — ремакс в Blob и скачивание (подходит для небольших файлов) или «скачать по частям».

3) Прогрессы
   - Индексация: показываем собственную полосу во время подсчёта sizes/prefix.
   - Байтовый прогресс: движется сразу после индексации, как доля отданных источником данных (served/total) — нет «тишины» до первого onProgress библиотеки.
   - Прогресс библиотеки: Conversion.onProgress (duration-based), может стартовать позже (библиотеке требуется время на оценку длительности).
   - Финализация: визуально покрывает работу между 100% библиотеки и завершением операции (закрытие файла/скачивание части).

4) «Скачать по частям» (без FS API, без SW)
   - Оцениваем битрейт: totalSize/duration → подбираем длину окна под целевой размер части (по умолчанию ~1 ГБ, можно 2 ГБ и т.д.).
   - Делаем оконный ремакс (Conversion с trim) → сразу скачиваем часть (BufferTarget) → освобождаем память → переходим к следующей.
   - Каждая часть — валидный WebM, открывается плеерами; при необходимости можно склеить оффлайн (например, ffmpeg).
   - Важно: много маленьких частей даёт большой оверхед по времени; лучше 2–4 ГБ на часть и меньшее число окон.

Известные нюансы

- Прогресс библиотеки (onProgress) стартует только после оценки длительности/подготовки пайплайнов; это нормально для длительных WebM без Cues.
- «Скачать по частям» медленнее, чем «запись в один файл», из‑за повторных инициализаций/финализаций на каждую часть.
- Большой Blob (fallback) может потребовать много ОЗУ; рекомендуется либо FS API, либо «по частям».

Что уже исправляли

- Ошибка ReadableStreamSource cache-miss → заменили на StreamSource (random-access), ввели индексацию и байтовый прогресс.
- TransactionInactiveError в курсоре на ранних версиях — переписали на короткоживущие транзакции/точечные get.
- `StreamTarget requires a WritableStream` — оборачиваем FileSystemWritableFileStream в WritableStream-sink.

Дальше (возможные улучшения)

1) Сохранять индекс (sizes/prefix) во время записи
   - Тогда на старте ремакса индексация станет мгновенной (только чтение одного документа в sessions).

2) Режим «по частям → файл» (только при FS API)
   - Писать части сразу в файлы без BufferTarget (ещё быстрее и без пиков по памяти).

3) «Быстрый режим» для частей
   - Отключить duration-based прогресс, оставить байтовый, упростить prefetch — больше UX, но может ускорить.

4) Выбор порога памяти
   - Автоматически подсказать размер части, исходя из доступной памяти/желательного пика, и пересчитать длительность окна.

Проверка/отладка

- Главная: обработка новой записи и существующих сессий (StreamSource → файл). Прогресс: индексация + байты.
- Сессии: индексация + байты + прогресс библиотеки + финализация; режим «по частям» (≈ N ГБ), итоговое время.
- Отладка (alt): варианты потоков, запись в файл, паддинг больших размеров.

Ссылки/файлы

- Главная: public/index.html (исходник: demo/index.html)
- Сессии: public/sessions.html (исходник: demo/sessions.html)
- Отладка: public/alt.html (исходник: demo/alt.html)
- Сервис: public/services/remuxService.js (исходник: demo/services/remuxService.js)

